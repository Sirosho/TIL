# Git Merge vs Git Rebase

| 항목          | Git Merge                                       | Git Rebase                                         |
| ----------- | ----------------------------------------------- | -------------------------------------------------- |
| **개념**      | 두 브랜치의 작업을 하나의 **새 커밋**으로 병합                    | 현재 브랜치 커밋을 **대상 브랜치 끝으로 재적용**                      |
| **작동 방식**   | 공통 조상 이후의 커밋을 새로운 커밋으로 병합                       | 대상 브랜치 커밋 뒤에 현재 브랜치 커밋을 하나씩 재작성                    |
| **명령어 예시**  | `git switch main`<br>`git merge feature-branch` | `git checkout feature-branch`<br>`git rebase main` |
| **히스토리 형태** | 브랜치가 합쳐진 **병렬적(비선형)** 히스토리                      | 브랜치가 이어진 **선형 히스토리**                               |
| **장점**      | - 커밋 히스토리 보존<br>- 충돌 시 병합 커밋에서 해결 가능            | - 깔끔한 선형 히스토리<br>- 흐름을 이해하기 쉬움                     |
| **단점**      | - 히스토리가 복잡해질 수 있음                               | - 충돌이 많으면 해결이 번거로움<br>- 공유 브랜치에 사용 시 위험            |

<br><br><br>

### Rebase를 사용하면 안되는 상황<br><br>

1. **공개된 브랜치에서의 Rebase**:
    - Rebase는 기존 커밋 히스토리를 다시 작성하므로, 이미 다른 팀원들과 공유된 브랜치에서 rebase를 사용하면 다른 사람들의 작업에 영향을 미칠 수 있습니다.
    - 공유된 브랜치에서 rebase를 사용하면 커밋 히스토리가 변경되어 다른 사람들의 로컬 저장소와의 불일치를 초래할 수 있습니다. 이는 매우 혼란스럽고, 충돌 해결을 어렵게 만듭니다.<br><br>
2. **협업 브랜치에서의 Rebase**:<br><br>
    - 여러 사람이 협업하는 브랜치에서 rebase를 사용하면, 각 팀원이 서로 다른 커밋 히스토리를 갖게 되어 충돌을 일으킬 수 있습니다.
    - 이 경우, merge를 사용하여 커밋 히스토리를 유지하는 것이 더 바람직합니다.

<br><br>
    ### 결론

- **Git Merge**는 히스토리를 그대로 유지하며 브랜치를 통합하는 안전하고 직관적인 방법입니다. 특히, 협업 브랜치나 공유된 브랜치에서 사용하기 적합합니다.
- **Git Rebase**는 선형적이고 깨끗한 히스토리를 유지하는 데 유리하지만, 공개된 브랜치에서는 사용을 피해야 합니다. 주로 개인 작업 브랜치에서 사용하여 로컬 히스토리를 정리하고, 최종적으로 병합할 때 merge를 사용하는 것이 좋습니다.
<br><br><br>
이 두 가지 방법을 상황에 맞게 적절히 사용하면, Git 히스토리를 깔끔하고 효율적으로 관리할 수 있습니다.



<br><br><br>

# Rebase의 Conflict 해결법

<br>
<br>
<br>

### - 첫번째는 `git rebase --abort` 명령어로 리베이스를 없던 일로 취소할 수 있습니다.

### - 두번째는 충돌 파일을 열어 컨플릭트를 해결한 후 `git rebase --continue` 명령어로 리베이스를 진행시키는 것.

Merge는 add commit을 했지만 이것은 add continue 하는 이유는
리베이스는 하나하나 커밋단위로 합치는 과정이기에 한땀한땀 수정한다고 생각하면 된다.

<br><br>

# 1. **Interactive Rebase란?**

- ### **정의**: Git의 `interactive rebase`는 커밋 히스토리를 세밀하게 수정, 재정렬, 합치기, 삭제할 수 있는 강력한 도구입니다. <br>
- ### **목적**: 깔끔한 커밋 히스토리를 유지하거나, 불필요한 커밋을 정리하고자 할 때 사용됩니다.

<br>

### 🔑 Push를 하기 전에 해야하는 작업이다. push후에 하면 커밋히스토리가 꼬이게 된다.


<br><br><br><br>

| `git rebase -i` 명령어 | 설명                             | 커밋 메시지 처리    | 사용 목적 / 예시                |
| ------------------- | ------------------------------ | ------------ | ------------------------- |
| `pick`              | 커밋을 그대로 적용                     | 그대로 유지       | 변경 없이 커밋을 재적용             |
| `reword`            | 커밋은 그대로 적용하되, 커밋 메시지를 수정       | 메시지 직접 수정 가능 | 메시지만 바꾸고 싶을 때             |
| `edit`              | 커밋 시점에서 작업 중지 → 커밋 내용을 수정 후 재개 | 유지           | 코드 수정, 파일 변경 등 커밋 내용 고칠 때 |
| `squash`            | 이전 커밋과 병합하며 메시지를 함께 편집         | 병합 메시지 편집 가능 | 커밋 여러 개를 하나로 합칠 때         |
| `fixup`             | 이전 커밋과 병합하지만 메시지는 버림           | 메시지 자동 생략    | 사소한 수정 커밋을 깔끔하게 병합할 때     |
| `drop`              | 해당 커밋을 완전히 삭제                  | 해당 없음        | 불필요한 커밋 제거 (ex. 디버깅용 커밋)  |




<br><br><br>










# Git Cherry-Pick

<br><br>

### `git cherrypick <Commit-hash>` 로 해당 커밋을 가져와서 붙인다.

<br>

### Git에서 특정 커밋을 골라서 현재 브랜치에 적용하는 기능 
<br><br><br><br><br>

# 언제 Cherry-Pick을 사용할까?
<br>

### Cherry-Pick은 다음과 같은 상황에서 특히 유용하다.
<br><br>

- 다른 브랜치에서 발견된 버그 수정을 현재 작업 중인 브랜치에도 적용하고 싶을 때
- 이전 버전에서 특정 기능만 현재 버전에 추가하고 싶을 때
- 여러 커밋 중에서 필요한 변경사항만 선택적으로 적용하고 싶을 때
- 다른 팀원이 작업한 특정 커밋만 내 브랜치에 적용하고 싶을 때

<br>

### `git cherrypick <Commit-hash>` 로 해당 커밋을 가져와서 붙인다.






<br><br>

| 구분        | Cherry-Pick       | Merge                   | Rebase                    |
| --------- | ----------------- | ----------------------- | ------------------------- |
| **주요 목적** | 특정 커밋만 선택적으로 반영   | 브랜치 전체를 병합              | 커밋 히스토리 정리 및 선형화          |
| **적용 범위** | 개별 커밋 단위          | 전체 브랜치 (변경사항 전부)        | 전체 브랜치 (기반 커밋부터 최신까지)     |
| **히스토리**  | 새로운 커밋 해시로 복사됨    | 원본 커밋 유지 + 병합 커밋 생성     | 커밋 히스토리를 다시 쓰며 새로운 해시 부여  |
| **병합 커밋** | 생성되지 않음           | 병합 커밋(Merge Commit) 생성됨 | 병합 커밋 없음                  |
| **충돌 처리** | 커밋 단위 충돌          | 브랜치 병합 중 충돌             | 리베이스 진행 중 충돌              |
| **용도**    | 필요한 커밋만 가져올 때     | 기능 브랜치를 메인 브랜치에 병합할 때   | 깔끔한 히스토리가 필요할 때, 협업 전 정리용 |
| **장점**    | 유연하게 커밋 선택 가능     | 모든 작업 이력 보존             | 이력이 직관적이고 깔끔해짐            |
| **단점**    | 이력이 분산되고 중복될 수 있음 | 커밋 히스토리가 복잡해질 수 있음      | 원본과 다른 히스토리 → 협업 중 주의 필요  |


<br><br>

# Git Tag의 전반적인 개념 

<br>

## Git에서 "태그(tag)"는 특정 커밋을 참조하기 위한 고정된 포인터<br><br> <br>

### 예를 들어, 소프트웨어 릴리스 버전을 표시하기 위해 태그를 사용한다.<br><br> 태그는 브랜치와 달리 변하지 않으며, 특정 커밋을 영구적으로 기록하는 데 사용.<br><br>"v1.0", "v2.0"과 같은 의미 있는 이름으로 특정 커밋을 쉽게 참조할 수 있으며,<br><br> 이는 코드의 버전 관리와 릴리스 사이클을 효율적으로 관리하는 데 매우 유용하다.


<br><br><br><br>


# Git tag 명령어

<br><br>

| **기능**                   | **명령어**                                                | **설명**                                              |
| ------------------------ | ------------------------------------------------------ | --------------------------------------------------- |
| Lightweight Tag 생성       | `git tag <tag_name>`                                   | 주어진 `<tag_name>`으로 lightweight 태그를 생성합니다.           |
| Annotated Tag 생성         | `git tag -a <tag_name> -m "Tag message"`               | 주어진 `<tag_name>`으로 annotated 태그 생성 + 메시지를 추가합니다.    |
| 이전 커밋에 Lightweight 태그 지정 | `git tag <tag_name> <commit_hash>`                     | 특정 커밋 `<commit_hash>`에 lightweight 태그를 지정합니다.       |
| 이전 커밋에 Annotated 태그 지정   | `git tag -a <tag_name> <commit_hash> -m "Tag message"` | 특정 커밋 `<commit_hash>`에 annotated 태그 + 메시지를 추가합니다.   |
| 태그 목록 조회                 | `git tag`                                              | 현재 리포지토리에 있는 모든 태그를 나열합니다.                          |
| 특정 패턴의 태그 목록 조회          | `git tag -l "<pattern>"`                               | `<pattern>`에 일치하는 태그들을 필터링하여 나열합니다.                 |
| 태그 세부 정보 확인              | `git show <tag_name>`                                  | 특정 태그 `<tag_name>`의 커밋 내용, 작성자, 메시지 등 세부 정보를 보여줍니다. |
| 로컬에서 태그 삭제               | `git tag -d <tag_name>`                                | 로컬 리포지토리에서 특정 태그 `<tag_name>`을 삭제합니다.               |
| 원격 리포지토리에 태그 푸시          | `git push origin <tag_name>`                           | 특정 태그 `<tag_name>`을 원격 리포지토리에 푸시합니다.                |
| 모든 태그 푸시                 | `git push origin --tags`                               | 로컬 리포지토리의 모든 태그를 원격 리포지토리에 푸시합니다.                   |
| 태그로 체크아웃                 | `git checkout <tag_name>`                              | 특정 태그로 체크아웃하여 **분리된 HEAD(detached HEAD)** 상태가 됩니다.  |
| 태그 기준으로 브랜치 생성           | `git checkout -b <new_branch_name> <tag_name>`         | 특정 태그를 기준으로 새로운 브랜치를 생성합니다.                         |


<br><br><br>
<br><br><br>

# Git reflog

<br>

### Git은 모든 참조업데이트(HEAD 이동)를 내부적으로 기록하며,<br><br> reflog 명령어를 통해 이 정보를 조회할 수 있다.

<br><br>

## 주요 기능 및 사용 상황

- **과거 커밋 복구**: 만약 브랜치를 잘못 리셋하거나, 커밋을 실수로 삭제한 경우, `git reflog`를 사용하여 해당 커밋의 해시를 찾고 복구할 수 있습니다. 예를 들어, `HEAD`가 어느 커밋을 가리키고 있었는지 추적할 수 있습니다.
- **브랜치 위치 추적**: 이전에 어떤 브랜치에 있었는지, 특정 브랜치가 어느 커밋을 가리키고 있었는지를 확인할 수 있습니다.
- **실수로 이동한 HEAD 복구**: 잘못된 리베이스나 리셋으로 인해 HEAD가 예상치 못한 위치로 이동했다면, `reflog`를 통해 이전 위치를 확인하고 되돌릴 수 있습니다.
- **커밋 히스토리 확인**: `git log`에 기록되지 않은(예: 재작성된 커밋) 최근 활동을 추적할 수 있습니다.

<br><br>

## `reflog`의 지역적인 특성 및 한계

<br>

### 1. **지역적인 특성**

- **로컬에서만 유효**: `reflog`는 **로컬 저장소에만 존재**합니다. 이는 로컬에서 발생한 모든 HEAD 이동 및 참조 변경 내역을 기록하는 반면, 원격 저장소에는 영향을 미치지 않습니다. 즉, `reflog`는 로컬 Git 환경에서 발생한 모든 작업을 추적하지만, 이 정보는 원격 저장소로 푸시되지 않으며, 다른 사용자와 공유되지 않습니다.

<br><br>

### 2. **영구적이지 않음**

- **자동 삭제**: `reflog` 기록은 영구적이지 않으며, 일정 기간이 지나면 자동으로 삭제됩니다. 기본적으로, `git reflog`는 약 90일 동안 기록을 유지한 후, 오래된 항목을 제거합니다. 또한, 가비지 컬렉션(Garbage Collection)이나 `git gc` 명령어를 실행할 때 `reflog` 기록이 삭제될 수 있습니다.
- **제한된 유지 기간**: 따라서 `reflog` 기록은 한시적으로만 보존되므로, 과거의 작업을 영구적으로 추적하거나 기록하려면 다른 방법을 사용해야 합니다. 중요한 커밋을 잃지 않으려면 이를 다른 브랜치로 체크아웃하거나 태그로 관리하는 것이 좋습니다.

<br><br><br>

| **형식**            | **의미**                | **예시**                    | **설명**                   |
| ----------------- | --------------------- | ------------------------- | ------------------------ |
| `HEAD@{n}`        | `n`번째 HEAD의 이동 이력을 참조 | `HEAD@{0}`                | 가장 최근 HEAD 위치 (현재)       |
|                   |                       | `HEAD@{3}`                | HEAD가 과거 3번째로 위치했던 커밋 참조 |
| `branch_name@{n}` | 특정 브랜치의 `reflog` 참조   | `main@{2}`                | `main` 브랜치의 2번째 이전 커밋 참조 |
| `HEAD@{<시간>}`     | 시간 기준 HEAD 참조         | `HEAD@{2.days.ago}`       | 이틀 전 HEAD가 가리켰던 커밋       |
|                   |                       | `HEAD@{yesterday}`        | 어제 HEAD가 가리켰던 커밋         |
|                   |                       | `HEAD@{2024-12-01 14:00}` | 해당 날짜/시간의 HEAD 위치        |



<br><br><br>

## 🔍 사용 예시<br><br>
### `git checkout HEAD@{3}`→ HEAD가 3번째 전 커밋을 가리키던 시점으로 이동 (detached HEAD 상태)

### `git reset --hard HEAD@{1}`→ HEAD를 이전 상태로 하드리셋 하기

### `git reflog` → 위에 나온 참조들이 의미하는 로그들을 리스트로 확인 가능

### `git reset --hard HEAD@{yesterday}` → 어제 시간으로 이동 
**Ex) 현재시간이 2025 05 15 14:00 라면 2025 05 14 14:00 이후에 기록된 가장 첫번째 refrog 항목으로 이동한다.** <br>
**만약 24시간 동안 reflog에 아무 변화도 없다면, Git은 그 이전의 가장 가까운 항목을 찾을 수도 있다.**


<br><br><br><br><br>





