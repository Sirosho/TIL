# ✅ IoC(제어의 역전) 요약

### 1. IoC의 개념

* IoC(Inversion of Control, 제어의 역전)은 **객체 생성과 제어 권한을 개발자가 아닌 프레임워크가 가지는 설계 원칙**이다.
* 전통적인 방식과 달리, 객체의 생성과 의존성 주입을 \*\*프레임워크(예: 스프링 컨테이너)\*\*가 대신 수행한다.
* 결과적으로 **결합도를 낮추고, 유연성과 유지보수성을 높일 수 있다.**

---

### 2. IoC 컨테이너 종류

| 구분    | BeanFactory         | ApplicationContext   |
| ----- | ------------------- | -------------------- |
| 역할    | 기본 IoC 컨테이너         | 고급 기능 포함 확장 IoC 컨테이너 |
| 로딩 방식 | 지연 로딩(Lazy Loading) | 즉시 로딩(Eager Loading) |
| 사용 환경 | 리소스 제한 환경           | 일반적인 스프링 애플리케이션      |
| 추가 기능 | 없음                  | 메시지 국제화, 이벤트 처리 등 포함 |

**ApplicationContext의 주요 구현체**

* `ClassPathXmlApplicationContext`: 클래스패스의 XML 사용
* `FileSystemXmlApplicationContext`: 파일 시스템의 XML 사용
* `AnnotationConfigApplicationContext`: 자바 설정 클래스(@Configuration 등) 사용

---

### 3. 스프링 IoC 컨테이너 동작 순서

1. **빈 정의(Bean Definition)**: XML, 애너테이션, 자바 설정으로 빈 구성
2. **빈 생성**: 컨테이너가 객체를 생성함
3. **의존성 주입(DI)**: 생성자, 세터, 필드 주입 방식으로 의존성을 해결함
4. **빈 초기화**: 초기화 메서드를 실행함
5. **빈 사용**: 애플리케이션에서 빈을 사용함
6. **빈 소멸**: 애플리케이션 종료 시 소멸 메서드를 실행함

---

### 요약 정리

* IoC는 객체의 생성과 관리를 프레임워크가 담당하게 하여 결합도를 낮추는 원칙이다.
* 스프링은 이를 위해 `BeanFactory`와 `ApplicationContext`라는 두 가지 IoC 컨테이너를 제공한다.


### 요즘은 대부분의 스프링 애플리케이션에서 ApplicationContext 를 사용한다.

### XML도 요새는 안쓰이는 추세이다.


---

<div style="margin-top:80px;"></div>

# ✅ 의존성 주입(DI) 요약

## 1. DI의 개념 및 중요성

* **의존성**이란 객체가 다른 객체를 필요로 하는 것을 의미한다.
* \*\*의존성 주입(DI, Dependency Injection)\*\*은 필요한 의존성을 객체 내부에서 직접 생성하지 않고 **외부에서 주입**받는 설계 패턴이다.

**DI의 장점**

* ✅ **결합도 감소**: 코드 변경이 용이함
* ✅ **테스트 용이**: Mock 객체 주입이 가능함
* ✅ **유연성 증가**: 런타임에 의존성 교체 가능함
* ✅ **재사용성 증가**: 구조가 유연하므로 재사용이 쉬움

---

<div style="margin-top:80px;"></div>

## 2. DI의 구현 방법

| 방식     | 설명                       | 특징                    |
| ------ | ------------------------ | --------------------- |
| 생성자 주입 | 생성자를 통해 의존성을 주입          | 객체 일관성 보장, 불완전 상태 방지  |
| 세터 주입  | 세터 메서드로 의존성을 주입          | 선택적 주입, 유연성 높음        |
| 필드 주입  | 필드에 직접 주입 (`@Autowired`) | 코드 간결하지만 테스트 어려움, 비권장 |

#### 2.1 생성자 주입 예시

```java
public class Car {
    private final Engine engine;

    public Car(Engine engine) {
        this.engine = engine;
    }

    public void startEngine() {
        engine.start();
    }
}
```

#### 2.2 세터 주입 예시

```java
public class Car {
    private Engine engine;

    public void setEngine(Engine engine) {
        this.engine = engine;
    }

    public void startEngine() {
        if (engine != null) engine.start();
        else System.out.println("No engine installed.");
    }
}
```

#### 2.3 필드 주입 예시 (비권장)

```java
public class Car {
    @Autowired
    private Engine engine;

    public void startEngine() {
        engine.start();
    }
}
```

※ **아직 필드 주입은 배우지 않았으므로 실제 구현에서는 생성자 또는 세터 주입을 사용하는 것이 더 바람직하다.**

---

<div style="margin-top:80px;"></div>

## 3. DI 적용 예시: 객체 관계 설정

* `Car` 클래스는 `Engine` 클래스에 의존한다.
* `Car` 객체는 `Engine` 객체를 외부에서 주입받음으로써 결합도를 낮추고, 다양한 구현체로 유연하게 교체할 수 있다.

<div style="margin-top:80px;"></div>

# 생성자 주입(Constructor Injection)을 선호하는 이유

생성자 주입은 스프링 프레임워크에서 가장 권장되는 의존성 주입 방식이다. 이는 객체 생성 시점에 모든 의존성을 주입함으로써 안정성과 일관성을 보장한다.

---

## 1. 불변성(Immutable) 보장

- 생성자 주입은 객체 생성과 동시에 모든 의존성을 주입받아 객체 상태가 불변하게 유지된다.
- 세터 주입은 이후에 의존성이 변경될 수 있어, 객체의 일관성이 깨질 수 있다.

---

## 2. 필수 의존성 강제

- 생성자에 의존성을 명시함으로써, 필수 의존성이 주입되지 않으면 객체 자체를 생성할 수 없다.
- 세터 주입은 선택적으로 주입이 가능하여, 누락 시 런타임 오류로 이어질 수 있다.

---

## 3. 불변 객체 생성 가능

- 생성자 주입을 통해 생성된 객체는 내부 상태 변경이 불가능한 불변 객체로 만들기 용이하다.
- 불변 객체는 스레드 안전(Thread-safe)하며 멀티스레드 환경에서 안정적으로 동작한다.

---

## 4. 테스트 용이성

- 생성자 기반으로 테스트 대상 객체를 명확하게 주입할 수 있어 단위 테스트 시 유리하다.
- 초기화되지 않은 세터 주입 객체는 테스트 시 예외 상황을 유발할 수 있다.

---

## 5. 순환 의존성 문제 사전 감지

- 생성자 주입은 애플리케이션 시작 시점에 순환 의존성(Circular Dependency) 문제를 바로 발견할 수 있다.
- 세터 주입은 런타임까지 순환 의존성이 감지되지 않아 예기치 못한 오류로 이어질 수 있다.

---

## 6. 가독성 높은 코드

- 생성자에 의존성이 명시되므로, 해당 객체가 어떤 의존성을 갖는지 코드를 통해 즉시 파악 가능하다.
- 세터 방식은 객체의 여러 위치에서 의존성이 주입되어 추적이 어려울 수 있다.

---

<div style="margin-top:80px;"></div>

## 결론

- 생성자 주입은 객체의 안정성과 예측 가능성을 높이는 가장 권장되는 DI 방식이다.
- 테스트, 유지보수, 코드 가독성, 오류 예방 측면에서 세터 주입보다 뛰어난 장점을 제공한다.
- 단, 일부 선택적인 의존성이 필요한 경우에는 세터 주입이 적절할 수 있다.

---

<div style="margin-top:80px;"></div>

## 요약

| 구분 | 생성자 주입 | 세터 주입 |
|------|--------------|------------|
| 불변성 유지 | 가능 | 불가능 |
| 필수 의존성 강제 | 가능 | 불가능 |
| 테스트 용이성 | 높음 | 낮음 |
| 가독성 | 높음 | 낮음 |
| 순환 의존성 발견 시점 | 컴파일 또는 초기화 시점 | 런타임 시점 |
| 선택적 의존성 처리 | 어려움 | 용이 |

> ✅ 일반적으로 **생성자 주입을 우선적으로 고려**하고, 특별한 이유가 있을 경우에만 세터 주입을 사용한다.
