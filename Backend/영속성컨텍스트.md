# 📌 영속성 컨텍스트와 EntityManager 정리

<div style="margin-top:80px;"></div>

## 1. 영속성 컨텍스트(Persistence Context)

* 영속성 컨텍스트란 JPA에서 엔티티 객체를 관리하는 1차 캐시 공간이다.
* 동일한 엔티티를 여러 번 조회하면 DB에 재조회하지 않고 캐시에서 반환한다.
* 트랜잭션 범위 내에서 엔티티의 동일성을 보장한다.
* 엔티티 값 변경 시 트랜잭션 커밋 시점에 자동으로 UPDATE SQL을 생성하여 반영한다. (Dirty Checking)
* INSERT, UPDATE, DELETE는 즉시 DB에 반영되지 않고 트랜잭션 커밋 시점에 한 번에 실행된다. (Write-behind)

---

<div style="margin-top:80px;"></div>

## 2. 엔티티 생명주기

1. **비영속 (Transient)**

   * `new` 키워드로 생성된 순수 자바 객체.
   * 영속성 컨텍스트에 포함되지 않음.

2. **영속 (Persistent)**

   * `persist()` 또는 `find()` 호출로 영속성 컨텍스트에 포함된 상태.
   * 1차 캐시 저장, 동일성 보장, Dirty Checking 적용.

3. **준영속 (Detached)**

   * `detach(entity)`, `clear()`, `close()` 호출 시 발생.
   * 객체는 메모리에 존재하지만 영속성 컨텍스트의 관리 대상에서 제외됨.
   * 변경해도 DB에 반영되지 않음.

4. **삭제 (Removed)**

   * `remove()` 호출로 삭제 예약 상태.
   * 트랜잭션 커밋 시 DELETE SQL 실행.

---

<div style="margin-top:80px;"></div>

## 3. EntityManager 역할

* 영속성 컨텍스트를 관리하는 핵심 객체이다.
* 엔티티의 생명주기를 전환하는 메서드를 제공한다.
* 주요 메서드:

  * `persist(entity)` : 비영속 → 영속
  * `find(EntityClass, id)` : 영속 조회
  * `detach(entity)` : 영속 → 준영속
  * `clear()` : 모든 엔티티 준영속 전환
  * `close()` : 영속성 컨텍스트 종료
  * `remove(entity)` : 영속/준영속 → 삭제 예약
  * `merge(entity)` : 준영속 → 영속 복귀
* 트랜잭션과 결합되어 commit, rollback, flush 시점에서 DB와 동기화한다.

---

<div style="margin-top:80px;"></div>

## ✅ 결론

* **영속성 컨텍스트**는 JPA에서 엔티티 객체를 캐싱하고 상태를 추적하여 트랜잭션과 DB를 연결하는 핵심 매커니즘이다.
* **EntityManager**는 영속성 컨텍스트를 제어하는 API로, 엔티티의 생명주기 관리와 DB 작업을 담당한다.


<div style="margin-top:80px;"></div>



# 📌 트랜잭션 범위(Transaction Scope)

## 1. 트랜잭션의 의미

* 트랜잭션(Transaction) = **데이터베이스 작업의 최소 단위**
* "모두 성공하거나(All or Nothing), 모두 실패해야 한다"는 원칙 보장 (ACID 성질 중 Atomicity)
* JPA에서 **영속성 컨텍스트의 변경사항이 DB에 반영되는 시점은 트랜잭션 커밋 시점**이다.

---

<div style="margin-top:80px;"></div>

## 2. Spring에서의 트랜잭션 관리

Spring에서는 `@Transactional` 어노테이션으로 트랜잭션을 선언한다.

### 기본 동작

```java
@Service
@Transactional
public class StudentService {

    public void saveStudent(Student s) {
        studentRepository.save(s);
    }
}
```

* `@Transactional`이 붙은 메서드 실행 시 → Spring이 **프록시**를 생성
* 메서드 시작할 때 → 트랜잭션 시작
* 메서드 정상 종료 시 → commit
* 예외 발생 시 → rollback

---

<div style="margin-top:80px;"></div>

## 3. 트랜잭션 범위

* 보통은 **메서드 단위**
* 클래스에 붙이면, 그 클래스의 모든 public 메서드에 적용
* 더 세밀하게, 특정 메서드에만 붙일 수도 있음

### 예시

```java
@Service
public class StudentService {

    @Transactional // save() 메서드 실행 시 트랜잭션 시작~종료
    public void save(Student student) {
        studentRepository.save(student);
    }

    public Student get(String id) {
        return studentRepository.findById(id).orElseThrow();
        // 트랜잭션이 없으므로 read-only 쿼리만 동작
    }
}
```

---

<div style="margin-top:80px;"></div>

## 4. 트랜잭션과 영속성 컨텍스트의 관계

* **트랜잭션 시작** 시점에 영속성 컨텍스트가 생성됨 (보통 스레드 단위)
* **트랜잭션 커밋** 시 flush → SQL 실행 → commit
* **트랜잭션 롤백** 시 flush 된 변경 내용도 무효화

📌 정리하면:
👉 `@Transactional` 범위 안에서만 **Dirty Checking → flush → commit**이 작동한다.
👉 그 범위 밖에서는 엔티티가 준영속 상태로 바뀌거나 단순 조회만 가능하다.

---

<div style="margin-top:80px;"></div>

## 5. 주의할 점

1. `@Transactional`은 기본적으로 **public 메서드**에만 적용된다.
2. 동일 클래스 내 private 메서드 호출에는 적용되지 않는다.
3. 기본 전파 속성(propagation) 때문에, 같은 트랜잭션 안에서 여러 Repository 호출 가능.
4. `readOnly = true` 옵션을 주면 Dirty Checking이 비활성화되어 성능이 향상된다.

---

<div style="margin-top:80px;"></div>

# ✅ 결론

* 영속성 컨텍스트의 모든 핵심 기능은 **트랜잭션 범위 내에서만 동작**한다.
* 트랜잭션의 범위는 보통 `@Transactional`이 붙은 **메서드 단위**이며, 클래스 단위로 선언하면 모든 public 메서드에 적용된다.
* 트랜잭션 종료 시점에 flush → commit 또는 rollback이 발생한다.



<div style="margin-top:80px;"></div>


# 📌 JPA에서 persist, flush, clear 자동 실행 시점

<div style="margin-top:80px;"></div>

## 1. persist()

* **자동 실행되지 않는다.**
* 새 엔티티를 영속성 컨텍스트에 등록하려면 **직접 호출**해야 함.
* Spring Data JPA의 `save()` 가 내부적으로 persist/merge 를 대신 호출하는 게 일반적.

```java
studentRepository.save(new Student(...)); // 내부적으로 em.persist()
```

---

<div style="margin-top:80px;"></div>

## 2. flush()

flush는 특정 시점에 **자동 실행**된다.

### ✅ 자동 flush 발생 시점

1. **트랜잭션 커밋 직전**

   ```java
   @Transactional
   public void saveStudent() {
       studentRepository.save(new Student("승현"));
       // 아직 INSERT SQL 안 나감
   } // 메서드 끝 → commit 발생 → flush 자동 실행 → INSERT SQL
   ```

2. **JPQL/CriteriaQuery 실행 직전**

   ```java
   studentRepository.save(new Student("철수"));
   em.createQuery("SELECT COUNT(s) FROM Student s").getSingleResult();
   // COUNT 쿼리 실행 전에 flush → INSERT SQL 실행
   ```

3. **네이티브 쿼리 실행 직전**

   ```java
   studentRepository.save(new Student("영희"));
   em.createNativeQuery("SELECT * FROM tbl_student").getResultList();
   // nativeQuery 실행 전에 flush 자동 발생
   ```

### ✅ 수동 flush 필요한 경우

* 제약 조건 위반 조기 감지
* 대용량 batch insert/update 시 메모리 관리
* 테스트 코드에서 DB 상태 즉시 확인

---

<div style="margin-top:80px;"></div>

## 3. clear()

* **자동 실행되지 않는다.**
* `em.clear()` 는 영속성 컨텍스트를 초기화(모든 엔티티 준영속 전환)하는 것이므로 JPA가 임의로 실행하지 않음.
* 보통 수동으로 사용하는 경우:

  * 대량 데이터 처리 시 1차 캐시 비워 메모리 사용량 줄이기
  * 테스트에서 DB 재조회 강제하기

---

<div style="margin-top:80px;"></div>

# 📌 종합 요약

| 메서드           | 자동 실행 여부 | 자동 실행 시점                                            | 수동 사용 목적                                         |
| ------------- | -------- | --------------------------------------------------- | ------------------------------------------------ |
| **persist()** | ❌        | 없음                                                  | 새 엔티티 등록                                         |
| **flush()**   | ✅        | - 트랜잭션 commit 직전<br>- JPQL/Criteria/Native 쿼리 실행 직전 | - 제약조건 조기 검증<br>- 대용량 batch 처리<br>- 테스트 DB 확인    |
| **clear()**   | ❌        | 없음                                                  | - 1차 캐시 비우기<br>- 준영속 상태 강제<br>- 대용량 처리 후 메모리 최적화 |

---

<div style="margin-top:80px;"></div>

# ✅ 결론

* **persist**: Spring Data JPA의 save()가 내부적으로 호출 (자동 실행 아님)
* **flush**: commit 직전, JPQL/Native 실행 직전에 자동 실행
* **clear**: 절대 자동 실행 안 함 → 오직 개발자가 직접 호출해야 함





<div style="margin-top:80px;"></div>


# 📌 EntityManager 주요 메서드 정리표

| 메서드                         | 역할                     | 상태 변화         | 비고                                     |
| --------------------------- | ---------------------- | ------------- | -------------------------------------- |
| **persist(entity)**         | 새 엔티티를 영속성 컨텍스트에 등록    | 비영속 → 영속      | commit 시 INSERT 실행                     |
| **find(Class, PK)**         | PK 기준 엔티티 조회           | 비영속 → 영속      | 1차 캐시 먼저 확인, 없으면 DB 조회                 |
| **getReference(Class, PK)** | 프록시 객체 반환 (실제 조회 지연)   | 비영속 → 영속      | Lazy Loading 용                         |
| **merge(entity)**           | 준영속 상태 엔티티를 다시 영속으로 병합 | 준영속 → 영속      | 새로운 영속 객체 반환                           |
| **remove(entity)**          | 엔티티 삭제 예약              | 영속 → 삭제       | commit 시 DELETE 실행                     |
| **detach(entity)**          | 특정 엔티티를 영속성 컨텍스트에서 분리  | 영속 → 준영속      | Dirty Checking 대상 제외                   |
| **clear()**                 | 영속성 컨텍스트 전체 초기화        | 영속 → 준영속 (전체) | 1차 캐시 완전 비움                            |
| **close()**                 | EntityManager 종료       | 전체 엔티티 준영속 전환 | 스레드 단위로 자원 해제                          |
| **flush()**                 | 변경 내역 DB 동기화           | 상태 변화 없음      | commit 전에도 SQL 실행                      |
| **refresh(entity)**         | DB 값으로 엔티티 다시 로딩       | 영속 상태 유지      | 1차 캐시 내용 덮어씀                           |
| **createQuery()**           | JPQL 실행 준비             | -             | JPQL 쿼리 작성                             |
| **createNativeQuery()**     | 네이티브 SQL 실행 준비         | -             | SQL 직접 실행                              |
| **getTransaction()**        | 트랜잭션 제어 객체 반환          | -             | `begin()`, `commit()`, `rollback()` 사용 |

---

<div style="margin-top:80px;"></div>

# 📌 사용 목적별 묶음

## 1. 생명주기 관리

* `persist()`, `find()`, `merge()`, `remove()`, `detach()`, `clear()`, `close()`

## 2. DB 동기화

* `flush()`, `refresh()`

## 3. 쿼리 실행

* `createQuery()`, `createNativeQuery()`

## 4. 트랜잭션 제어

* `getTransaction()`

---

<div style="margin-top:80px;"></div>

# ✅ 결론

* **persist / find / merge / remove** → 엔티티 생명주기 전환
* **flush / refresh** → DB 동기화 관련
* **clear / detach / close** → 캐시 및 영속성 컨텍스트 관리
* **createQuery / createNativeQuery** → 조회용 쿼리 실행
* **getTransaction** → 트랜잭션 관리
