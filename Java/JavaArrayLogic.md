

# 배열 메서드 알고리즘

-----

# Java Basic

## 📄 배열 복사 알고리즘

자바에서 배열을 복사할 때는 단순히 변수끼리 할당(`=` 연산자)하는 것만으로는 충분하지 않다. 그 이유는 배열 변수가 실제 데이터를 저장하는 것이 아니라, 힙(Heap) 메모리에 있는 \*\*배열 데이터의 주소(참조)\*\*를 저장하기 때문이다.

만약 `String[] petsCopy = pets;`와 같이 코드를 작성하면, `petsCopy` 변수도 `pets` 변수와 **동일한 배열의 주소를 가리키게 된다.** 결과적으로 두 변수가 같은 배열을 공유하게 되므로, `petsCopy`를 통해 배열의 내용을 변경하면 `pets`가 가리키는 배열의 내용도 함께 변경된다. 이는 '복사'라기보다는 '공유'에 가깝다.

진정한 의미의 배열 복사, 즉 원본 배열과 내용이 같지만 **별개의 새로운 배열을 만드는 것**을 '깊은 복사(Deep Copy)'라고 한다.

### 📝 배열 복사 방법

자바에서 배열을 올바르게 복사하는 방법은 크게 두 가지가 있다.

#### 1\. 수동 복사 (반복문 사용)

가장 기본적인 방법으로, 새로운 배열을 생성한 후 반복문을 사용하여 원본 배열의 각 요소를 새 배열에 하나씩 복사하는 방식이다.

```java
import java.util.Arrays; // 배열 내용을 출력하기 위해 필요

public class ArrayCopy {

    public static void main(String[] args) {

        String[] pets = {"멍멍이", "야옹이", "짹짹이"};

        // 1. 원본과 같은 길이의 새로운 배열을 생성한다.
        String[] petsCopy = new String[pets.length];

        // 2. 반복문을 사용하여 원본 배열의 모든 값을 새 배열로 복사한다.
        for (int i = 0; i < pets.length; i++) {
            petsCopy[i] = pets[i];
        }

        // petsCopy[1]의 값을 변경해도 원본 pets에는 영향을 주지 않는다.
        petsCopy[1] = "어흥이";

        System.out.println("원본 주소: " + pets);      // 예: @4c873330 (원본 배열의 주소)
        System.out.println("사본 주소: " + petsCopy); // 예: @5c984441 (새로 생성된 사본 배열의 주소)

        System.out.println("원본: " + Arrays.toString(pets));      // 출력: 원본: [멍멍이, 야옹이, 짹짹이]
        System.out.println("사본: " + Arrays.toString(petsCopy)); // 출력: 사본: [멍멍이, 어흥이, 짹짹이]
    }
}
```

이 방법을 사용하면 `pets`와 `petsCopy`는 서로 다른 메모리 공간을 가리키는 별개의 배열이 된다. 따라서 `petsCopy`의 내용을 변경해도 `pets`의 내용은 그대로 유지된다.

#### 2\. `Arrays.copyOf()` 메서드 사용 (간편한 방법)

자바의 `java.util.Arrays` 클래스에서 제공하는 `copyOf()` 메서드를 사용하면 배열 복사를 훨씬 쉽고 간결하게 처리할 수 있다.

* 복사할 길이를 원본 배열의 길이(pets.length)와 같게 지정하면 전체가 복사된다.
* 만약 복사할 길이를 원본보다 길게 지정하면, 남는 공간은 해당 타입의 기본값으로 채워진다.

```java
import java.util.Arrays; // Arrays.copyOf() 사용을 위해 필요

public class ArrayCopy {

    public static void main(String[] args) {

        String[] pets = {"멍멍이", "야옹이", "짹짹이"};

        // Arrays.copyOf(원본배열, 복사할 길이) 메서드를 사용하여 배열을 복사한다.
        // 복사할 길이를 원본 배열의 길이(pets.length)와 같게 지정하면 전체가 복사된다.
        // 만약 복사할 길이를 원본보다 길게 지정하면, 남는 공간은 해당 타입의 기본값으로 채워진다.
        String[] petsCopy = Arrays.copyOf(pets, pets.length);

        petsCopy[1] = "어흥이"; // 사본 배열의 값을 변경한다.

        System.out.println("원본 주소: " + pets);      // 예: @4c873330
        System.out.println("사본 주소: " + petsCopy); // 예: @5c984441 (원본과 다른 주소)

        System.out.println("원본: " + Arrays.toString(pets));      // 출력: 원본: [멍멍이, 야옹이, 짹짹이]
        System.out.println("사본: " + Arrays.toString(petsCopy)); // 출력: 사본: [멍멍이, 어흥이, 짹짹이]
    }
}
```

























## ➕ 배열에 데이터 추가하기 (Push) 알고리즘

자바에서 **배열은 한 번 생성되면 크기를 바꿀 수 없다.** 이는 배열의 중요한 특징 중 하나다. 하지만 프로그램을 만들다 보면 배열에 새로운 데이터를 추가해야 할 때가 생긴다. 이때는 기존 배열보다 더 큰 새로운 배열을 만들고, 기존 데이터를 복사한 뒤 새 데이터를 추가하는 방식을 사용한다.

이 과정은 마치 꽉 찬 상자에 물건을 더 넣고 싶을 때, 더 큰 상자를 가져와 기존 물건들을 옮기고 새 물건을 추가하는 것과 비슷하다.

### 📝 데이터 추가 (Push) 알고리즘 단계

```java
import java.util.Arrays; // 배열 내용을 출력하기 위해 필요

public class ArrayPush {

    static int[] numbers = {10, 20, 30, 40}; // 전역으로 선언된 배열

    public static void main(String[] args) {

        int newNumber = 50;

        // 1. 기존 배열보다 한 칸 더 큰 임시 배열을 생성한다.
        // 예를 들어, numbers의 길이가 4면, tempArray는 길이가 5가 된다.
        int[] tempArray = new int[numbers.length + 1];

        // 2. 원본 배열(numbers)의 모든 값들을 새 임시 배열(tempArray)로 복사한다.
        // tempArray의 0번 인덱스부터 numbers의 값들이 순서대로 채워진다.
        for (int i = 0; i < numbers.length; i++) {
            tempArray[i] = numbers[i];
        }

        // 3. 임시 배열의 마지막 인덱스(가장 끝 부분)에 새로운 값을 저장한다.
        // tempArray의 크기가 numbers.length + 1 이므로, 마지막 인덱스는 (numbers.length + 1) - 1, 즉 numbers.length가 된다.
        tempArray[tempArray.length - 1] = newNumber;

        // 4. 원본 배열 변수(numbers)가 새롭게 만든 임시 배열(tempArray)의 주소를 참조하도록 교체한다.
        // 이제 numbers는 더 커진 새 배열을 가리키게 된다.
        numbers = tempArray;

        // 5. 사용이 끝난 임시 배열 변수(tempArray)의 참조를 끊어준다.
        // 이렇게 하면 더 이상 사용하지 않는 메모리 공간은 자바의 가비지 컬렉터가 나중에 정리하게 된다.
        tempArray = null;

        System.out.println("numbers (50 추가 후): " + Arrays.toString(numbers)); // [10, 20, 30, 40, 50]
        System.out.println("tempArray (null): " + Arrays.toString(tempArray)); // null (참조가 끊겼으므로)

        // 이 과정을 메서드로 만들면 재사용성을 높일 수 있다.
        // 아래는 main 메서드 내에서 재차 push를 시도한 예시로,
        // 위 코드를 재사용 가능한 push 메서드로 만들었을 때의 결과와 같다.
        // (단, 이 코드에서는 실제 push 메서드가 정의되어 있지 않다.)
        // push(numbers, 90);
        // push(numbers, 100);
        // push(numbers, 200);
        // System.out.println("numbers (추가): " + Arrays.toString(numbers));
    }

    // 만약 push 기능을 메서드로 만든다면 아래와 같은 형태가 된다.
    // 이 메서드는 배열을 받아 처리하고, 크기가 변경된 새 배열을 반환해야 한다.
    /*
    public static int[] push(int[] arr, int newData) {
        int[] temp = new int[arr.length + 1];
        for (int i = 0; i < arr.length; i++) {
            temp[i] = arr[i];
        }
        temp[temp.length - 1] = newData;
        return temp; // 새 배열의 주소를 반환
    }
    */
}
```

### 🧠 알고리즘의 핵심 원리

이 알고리즘은 다음과 같은 원리로 작동한다.

1.  **새로운 공간 확보**: 기존 배열이 꽉 찼으므로, 새 데이터를 담을 수 있는 더 큰 공간(`tempArray`)을 확보한다.
2.  **데이터 이전**: 기존 배열에 있던 모든 데이터를 새로 확보한 공간으로 옮긴다.
3.  **새 데이터 추가**: 새로운 데이터를 비어있는 마지막 칸에 넣는다.
4.  **참조 교체**: 이제 원래 사용하던 배열 변수(`numbers`)가 새로 만든 더 큰 배열을 가리키도록 주소를 변경한다. 이렇게 하면 프로그램에서는 마치 배열의 크기가 늘어난 것처럼 인식하게 된다.






## ➖ 배열 데이터 맨 끝 제거하기 (Pop) 알고리즘

자바 배열에서 마지막 데이터를 제거하는 `pop` 연산은, 데이터를 추가하는 `push` 연산과 마찬가지로 **새로운 배열을 생성하고 데이터를 복사**하는 방식으로 진행된다. 배열은 한 번 만들어지면 크기를 바꿀 수 없기 때문이다. 이 과정은 마치 물건이 가득 찬 상자에서 맨 위 물건을 하나 빼내고, 그 나머지를 더 작은 새 상자에 옮겨 담는 것과 같다.

### 📝 데이터 제거 (Pop) 알고리즘 단계

```java
import java.util.Arrays; // 배열 내용을 출력하기 위해 필요

public class ArrayPop {

    public static void main(String[] args) {

        int[] numbers = {10, 20, 30, 40, 50, 60};

        // pop: 배열의 맨 끝 데이터를 제거하면서 그 값을 반환하는 연산

        // 0. 지워질 데이터를 미리 백업한다.
        // 이 값은 나중에 사용할 수 있도록 변수에 저장된다.
        int delTarget = numbers[numbers.length - 1]; // numbers의 마지막 요소 (60)

        // 1. 기존 배열의 사이즈보다 1개 작은 새로운 임시 배열을 생성한다.
        // 예를 들어, numbers의 길이가 6이라면, temp 배열은 길이가 5가 된다.
        int[] temp = new int[numbers.length - 1];

        // 2. 새 임시 배열에 원본 배열의 데이터 중 마지막 하나를 제외하고 모두 복사한다.
        // temp 배열의 길이는 numbers.length - 1이므로, 마지막 요소는 자동으로 제외된다.
        for (int i = 0; i < temp.length; i++) {
            temp[i] = numbers[i];
        }

        // 3. 원본 배열 변수(numbers)가 새롭게 만든 임시 배열(temp)의 주소를 참조하도록 교체한다.
        // 이제 numbers는 마지막 요소가 제거된 새 배열을 가리킨다.
        numbers = temp;

        // 4. 사용이 끝난 임시 배열 변수(temp)의 참조를 끊어준다.
        // 이렇게 하면 해당 메모리 공간은 자바의 가비지 컬렉터가 나중에 정리한다.
        temp = null;

        System.out.println("numbers (pop 후): " + Arrays.toString(numbers)); // 출력: [10, 20, 30, 40, 50]
        System.out.println("제거된 데이터: " + delTarget); // 출력: 60
        System.out.println("temp (null): " + Arrays.toString(temp)); // 출력: null (참조가 끊겼으므로)
    }
}
```

### 🧠 알고리즘의 핵심 원리

이 `pop` 알고리즘은 다음 단계들을 거쳐 작동한다.

1.  **데이터 백업**: 제거될 마지막 요소를 미리 따로 저장한다. 이렇게 하면 나중에 그 값을 활용할 수 있다.
2.  **새로운 공간 생성**: 기존 배열보다 한 칸 작은 새 배열 공간을 확보한다. 이 공간은 마지막 요소를 제외한 나머지 데이터를 담게 된다.
3.  **데이터 복사**: 원본 배열에서 마지막 요소를 제외한 나머지 모든 데이터를 새로운 작은 배열로 옮긴다.
4.  **참조 교체**: 원래 배열 변수가 이제 새로 만들어진, 더 작은 배열을 가리키도록 주소를 변경한다. 이로써 겉으로 보기에는 배열의 크기가 줄어들고 마지막 요소가 사라진 것처럼 인식된다.

이 방식은 자바의 고정 크기 배열 특성 때문에 필요한 작업이다. `ArrayList`와 같은 **동적 배열(Dynamic Array)** 컬렉션들은 내부적으로 이와 유사한 방식으로 동작하여 배열의 크기를 자동으로 관리해주므로, 개발자가 직접 이러한 로직을 구현할 필요 없이 더 편리하게 데이터를 추가하거나 제거할 수 있다.



## 🔍 배열 탐색: 선형(순차) 탐색 알고리즘

배열에서 원하는 데이터를 찾는 가장 기본적인 방법은 처음부터 끝까지 하나씩 확인하는 \*\*선형(순차) 탐색(Linear Search)\*\*이다. 이 방식은 마치 서랍을 열어 물건을 찾을 때, 첫 번째 서랍부터 마지막 서랍까지 하나씩 열어보는 것과 같다.

### 📝 선형 탐색 알고리즘 단계

```java
public class ArraySearch {

    public static void main(String[] args) {

        // 배열: 탐색 대상이 되는 데이터들이 저장된 공간
        String[] foods = {"족발", "파스타", "치킨", "삼겹살"};

        // 타겟: 배열에서 찾으려는 값
        String target = "양념치킨";

        // 선형 탐색 과정: 0번 인덱스부터 배열의 끝까지 순차적으로 확인한다.

        // 타겟의 인덱스를 저장할 변수. 찾지 못했을 경우를 대비해 -1로 초기화한다.
        int index = -1;

        // 배열의 모든 요소를 순회한다.
        for (int i = 0; i < foods.length; i++) {
            // 현재 배열의 요소(foods[i])가 찾으려는 타겟(target)과 같은지 비교한다.
            // 자바에서 문자열 비교 시에는 반드시 .equals() 메서드를 사용해야 한다.
            // == 연산자는 문자열의 '값'이 아닌 '메모리 주소'를 비교하기 때문이다.
            if (target.equals(foods[i])) {
                index = i; // 타겟을 찾으면 해당 인덱스를 저장한다.
                break;     // 찾았으므로 더 이상 탐색할 필요가 없어 반복문을 즉시 종료한다.
            }
        }

        // 타겟의 유무 확인: 인덱스 값이 -1이 아니면 타겟이 배열 안에 존재하는 것이다.
        boolean isPresent = index != -1;

        System.out.println("타겟의 인덱스: " + index);      // 출력: 타겟의 인덱스: -1 (양념치킨은 배열에 없으므로)
        System.out.println("타겟의 유무: " + isPresent); // 출력: 타겟의 유무: false
    }
}
```

### 🧠 알고리즘의 핵심 원리 및 특징

  * **순차적 탐색**: 배열의 첫 번째 요소부터 마지막 요소까지 순서대로 하나씩 비교하며 원하는 값을 찾는다.
  * **문자열 비교 주의**: 자바에서 **문자열의 값을 비교할 때는 반드시 `.equals()` 메서드를 사용**해야 한다. `==` 연산자는 두 문자열 변수가 같은 메모리 주소를 가리키는지(즉, 완전히 동일한 객체인지)를 비교하므로, 내용이 같더라도 다른 객체일 수 있는 문자열 비교에는 적합하지 않다.
  * **탐색 중단**: 타겟을 찾으면 더 이상 배열을 탐색할 필요가 없으므로 `break` 문을 사용하여 반복문을 즉시 종료한다. 이는 불필요한 연산을 줄여 효율성을 높인다.
  * **결과**:
      * 타겟을 찾으면 해당 **인덱스**를 반환한다.
      * 타겟을 찾지 못하면 초기값으로 설정했던 \*\*`-1`\*\*을 반환한다.
      * 이를 통해 타겟의 존재 유무도 쉽게 판단할 수 있다. (`index != -1`이 `true`이면 존재, `false`이면 존재하지 않음)

선형 탐색은 구현이 매우 간단하지만, 배열의 크기가 커질수록 모든 요소를 확인해야 할 가능성이 높아져 성능이 저하될 수 있다. 따라서 데이터의 양이 적거나, 데이터가 정렬되지 않은 경우에 주로 사용된다.




## 📥 배열 데이터 원하는 위치에 삽입하기 (Insert) 알고리즘

자바 배열은 한 번 생성되면 크기를 바꿀 수 없다. 따라서 배열의 특정 위치에 새로운 데이터를 삽입하려면, 기존 배열보다 한 칸 더 큰 새로운 배열을 만든 후, 데이터들을 적절히 옮기고 새 데이터를 삽입하는 복잡한 과정을 거쳐야 한다.

이 과정은 마치 중간에 빈칸을 만들고 싶을 때, 뒤에 있는 물건들을 한 칸씩 밀어낸 다음 그 빈칸에 새 물건을 넣는 것과 비슷하다.

### 📝 데이터 삽입 (Insert) 알고리즘 단계

```java
import java.util.Arrays; // 배열 내용을 출력하기 위해 필요

public class ArrayInsert {

    public static void main(String[] args) {

        int[] numbers = {10, 50, 90, 100, 150};

        int targetIndex = 2; // 데이터를 삽입할 위치 (인덱스)
        int newNumber = 77;  // 새로 삽입할 데이터

        /*
            삽입 과정 시뮬레이션 (targetIndex가 2, newNumber가 77일 때)

            초기 배열 (numbers): [ 10, 50, 90, 100, 150 ]

            1. 먼저 사이즈가 1개 더 큰 새 임시 배열(temp)을 생성한다.
               temp: [ 10, 50, 90, 100, 150, 0 ] (기존 값 복사 + 마지막 칸은 기본값 0)

            2. 삽입할 위치(targetIndex)부터 마지막까지의 데이터를 한 칸씩 뒤로 민다.
               temp[5] = temp[4] -> [ 10, 50, 90, 100, 150, 150 ]
               temp[4] = temp[3] -> [ 10, 50, 90, 100, 100, 150 ]
               temp[3] = temp[2] -> [ 10, 50, 90, 90, 100, 150 ]
               (반복문이 targetIndex(2)까지 내려오면 종료)

            3. targetIndex 위치에 새로운 값을 삽입한다.
               temp[2] = 77      -> [ 10, 50, 77, 90, 100, 150 ]
        */

        // 1. 기존 배열보다 사이즈가 1칸 더 큰 새로운 임시 배열을 생성한다.
        int[] temp = new int[numbers.length + 1];

        // 2. 원본 배열(numbers)의 값들을 새 임시 배열(temp)로 모두 복사한다.
        // 이 단계까지 temp는 원본 numbers와 같은 값들을 가지고 있으며, 마지막 인덱스만 비어있다(기본값 0).
        for (int i = 0; i < numbers.length; i++) {
            temp[i] = numbers[i];
        }

        // 3. 삽입할 `targetIndex`부터 배열의 끝까지의 데이터를 한 칸씩 뒤로 민다.
        // 이 과정은 뒤에서부터 앞으로 값을 복사해야 데이터 손실이 없다.
        // 예를 들어, 인덱스 4의 값을 인덱스 5로, 인덱스 3의 값을 인덱스 4로 옮기는 식이다.
        for (int i = temp.length - 1; i > targetIndex; i--) {
            temp[i] = temp[i - 1];
        }

        // 4. 비워진 `targetIndex` 위치에 새로운 값을 저장한다.
        temp[targetIndex] = newNumber;

        // 5. 원본 배열 변수(numbers)가 새롭게 만든 임시 배열(temp)의 주소를 참조하도록 교체한다.
        // 이제 numbers는 새로운 요소가 삽입된 배열을 가리킨다.
        numbers = temp;

        // 6. 사용이 끝난 임시 배열 변수(temp)의 참조를 끊어준다.
        // 이렇게 하면 더 이상 사용하지 않는 메모리 공간은 자바의 가비지 컬렉터가 나중에 정리한다.
        temp = null;

        System.out.println(Arrays.toString(numbers)); // 출력: [10, 50, 77, 90, 100, 150]
    }
}
```

### 🧠 알고리즘의 핵심 원리

이 **데이터 삽입 알고리즘**은 다음 단계들을 따른다.

1.  **새로운 공간 확보**: 데이터를 삽입하려면 기존 배열보다 한 칸 더 넓은 공간이 필요하다. 따라서 크기가 1 늘어난 새 배열(`temp`)을 생성한다.
2.  **기존 데이터 복사**: 원본 배열의 모든 데이터를 새 배열로 복사한다. 이 시점에서는 아직 새 데이터가 삽입될 공간은 비어있지 않다 (뒤로 밀릴 데이터가 그 자리를 차지하고 있다).
3.  **데이터 밀어내기**: 삽입할 `targetIndex`부터 배열의 마지막까지의 데이터를 한 칸씩 뒤로 민다. 이 과정에서 `targetIndex`에 새 데이터가 들어갈 빈 공간이 생긴다. **가장 뒤에서부터 시작해야** 기존 데이터가 덮어씌워지지 않고 올바르게 밀려난다.
4.  **새 데이터 삽입**: 비워진 `targetIndex` 위치에 새로운 데이터를 삽입한다.
5.  **참조 교체**: 원래 배열 변수(`numbers`)가 이제 새로 만들어진, 데이터가 삽입된 배열의 주소를 가리키도록 변경한다.

이 방식은 자바 배열의 고정 크기 특성 때문에 필수적으로 사용된다. `ArrayList`와 같은 **동적 배열(Dynamic Array)** 컬렉션들은 이러한 복잡한 삽입 로직을 내부적으로 처리해주므로, 개발자는 직접 구현할 필요 없이 더 편리하게 데이터를 관리할 수 있다.






## 🗑️ 배열 데이터 원하는 위치 삭제하기 (Delete) 알고리즘

자바에서 배열은 한 번 생성되면 크기를 바꿀 수 없다는 특징 때문에, 배열의 특정 위치에 있는 데이터를 삭제하는 과정은 다소 복잡하다. 단순히 데이터를 없애는 것이 아니라, 마치 빈자리가 생기면 뒤에 있는 물건들을 한 칸씩 앞으로 당겨 빈자리를 채우고, 마지막에 남는 공간을 잘라내는 것과 같다.

### 📝 데이터 삭제 (Delete) 알고리즘 단계

```java
import java.util.Arrays; // 배열 내용을 출력하기 위해 필요

public class ArrayDelete {

    public static void main(String[] args) {

        int[] numbers = {1, 3, 5, 7, 9, 11};

        int targetIndex = 1; // 삭제할 데이터의 인덱스 (여기서는 3을 삭제)

        /*
         * 삭제 알고리즘 시뮬레이션 (targetIndex가 1일 때)
         *
         * 초기 배열 (numbers): [ 1, 3, 5, 7, 9, 11 ]
         *
         * 1. 삭제할 위치(targetIndex)부터 뒤에 있는 데이터들을 한 칸씩 앞으로 당긴다.
         * numbers[1] = numbers[2] -> [ 1, 5, 5, 7, 9, 11 ]
         * numbers[2] = numbers[3] -> [ 1, 5, 7, 7, 9, 11 ]
         * numbers[3] = numbers[4] -> [ 1, 5, 7, 9, 9, 11 ]
         * numbers[4] = numbers[5] -> [ 1, 5, 7, 9, 11, 11 ]
         * (반복문은 numbers.length-1 까지 돌며, 마지막 요소는 그대로 두거나 뒤로 밀려난 값이 중복됨)
         *
         * 결과: [ 1, 5, 7, 9, 11, 11 ] (마지막 요소가 중복되거나 의미 없는 값이 됨)
         *
         * 2. 이제 논리적으로는 삭제되었지만, 물리적으로 배열의 크기는 그대로이므로
         * 마지막에 남은 중복되거나 필요 없는 요소를 제거하기 위해 Pop 알고리즘을 적용한다.
         * 즉, 크기가 1 줄어든 새 배열을 생성하고 유효한 데이터만 복사한다.
         * 새로운 temp 배열 생성: [ 1, 5, 7, 9, 11 ]
         */

        // 1. 삭제할 `targetIndex`부터 배열의 끝까지의 데이터를 한 칸씩 앞으로 당긴다.
        // 이렇게 하면 삭제될 요소의 자리가 뒤에 있는 요소들로 채워진다.
        for (int i = targetIndex; i < numbers.length - 1; i++) {
            numbers[i] = numbers[i + 1];
        }
        // 이 시점에서 numbers 배열은 마지막 요소가 중복되거나 더 이상 유효하지 않은 상태가 된다.
        // 예: [1, 5, 7, 9, 11, 11]

        // 2. 이제 실제 배열의 크기를 줄이기 위해, 기존 사이즈보다 1개 작은 새로운 임시 배열을 생성한다.
        int[] temp = new int[numbers.length - 1];

        // 3. 새 임시 배열에 원본 배열의 유효한 데이터만 복사한다.
        // 즉, `numbers` 배열의 마지막 (중복된) 요소를 제외하고 복사한다.
        for (int i = 0; i < temp.length; i++) {
            temp[i] = numbers[i];
        }

        // 4. 원본 배열 변수(numbers)가 새롭게 만든 임시 배열(temp)의 주소를 참조하도록 교체한다.
        // 이제 numbers는 원하는 요소가 삭제되고 크기가 줄어든 배열을 가리키게 된다.
        numbers = temp;

        // 5. 사용이 끝난 임시 배열 변수(temp)의 참조를 끊어준다.
        // 이렇게 하면 해당 메모리 공간은 자바의 가비지 컬렉터가 나중에 정리한다.
        temp = null;

        System.out.println(Arrays.toString(numbers)); // 출력: [1, 5, 7, 9, 11]
    }
}
```

### 🧠 알고리즘의 핵심 원리

이 **데이터 삭제 알고리즘**은 다음 단계들을 따른다.

1.  **데이터 당겨오기**: 삭제할 `targetIndex`부터 뒤에 있는 모든 데이터를 한 칸씩 앞으로 이동시켜, 삭제될 데이터를 덮어씌운다. 이 과정 후 배열의 마지막 요소는 중복되거나 의미 없는 값이 된다.
2.  **새로운 공간 생성 및 복사**: 배열의 크기는 고정되어 있으므로, 실제 크기를 줄이기 위해 **삭제된 요소를 제외한 길이**의 새로운 배열을 생성한다. 그리고 앞에서 데이터를 당겨온 결과인 기존 배열의 유효한 부분만 이 새 배열로 복사한다.
3.  **참조 교체**: 원래 배열 변수가 새로 생성된, 크기가 줄어든 배열의 주소를 가리키도록 변경한다.

이 방식은 자바 배열의 고정 크기 특성 때문에 필요하다. `ArrayList`와 같은 **동적 배열(Dynamic Array)** 컬렉션들은 내부적으로 이러한 복잡한 삭제 로직을 자동으로 처리해주므로, 개발자가 직접 구현할 필요 없이 더 편리하게 데이터를 관리할 수 있다.
