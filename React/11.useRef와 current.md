
# React `useRef`

`useRef`는 React에서 DOM 요소에 직접 접근하거나, 렌더링과 관계없이 컴포넌트의 수명 동안 유지되는 가변(mutable) 데이터를 관리하기 위한 Hook이다. `useState`와 달리 `useRef`의 값은 변경되어도 컴포넌트를 다시 렌더링하지 않는다.

-----

<div style="margin-top:100px;"></div>

## 1. `useRef`란 무엇인가? 🤔

`useRef`는 React 컴포넌트에서 특정 값을 '참조'하기 위해 사용되는 Hook으로, 두 가지 주요 목적을 가진다.

### 1.1. DOM 요소에 접근

가장 일반적인 사용 사례로, `ref`를 통해 렌더링된 DOM 요소에 직접 접근할 수 있다. 이를 통해 특정 `input`에 포커스를 주거나, 요소의 크기를 측정하거나, 외부 라이브러리와 연동하는 등의 작업을 수행할 수 있다.

### 1.2. 렌더링과 무관한 값 저장

`useState`는 값이 변경될 때마다 컴포넌트를 재렌더링하지만, 때로는 재렌더링을 유발하지 않으면서 값을 기억하고 싶을 때가 있다. `useRef`는 이러한 값을 저장하기에 완벽한 도구이다. 예를 들어, **이전 state 값, 타이머의 ID, 반복 렌더링 사이에서 유지되어야 하는 계산 결과** 등을 저장하는 데 사용된다.

-----

<div style="margin-top:100px;"></div>

## 2. `useRef`와 `.current`의 기본 원리

`useRef`를 처음 접할 때 가장 혼란스러운 부분은 왜 항상 `.current`를 통해 값에 접근해야 하는가이다. 결론적으로, \*\*`.current`는 `useRef`가 생성한 참조 객체(ref object)가 실제 값을 담고 있는 유일한 속성(property)\*\*이다.

<div style="margin-top:100px;"></div>

### 2.1. 참조 객체: 내용물을 담는 '상자' 📦

`useRef`는 단순한 변수가 아니라, React가 특별하게 관리하는 \*\*객체(상자)\*\*를 반환한다.

```javascript
const myRef = useRef(null);

// 이 시점의 myRef는 다음과 같은 형태의 '객체'이다.
// myRef = { current: null }
```

React는 이 `myRef`라는 **'상자' 자체는 절대로 바꾸지 않는다.** 컴포넌트가 몇 번이고 다시 렌더링되어도 `myRef`는 항상 메모리상의 동일한 객체를 가리킨다. 대신 React는 그 상자 안의 내용물, 즉 `.current` 프로퍼티의 값만 변경해 준다.

이러한 설계 방식은 다음과 같은 장점을 가진다.

  * **일관성**: 컴포넌트의 전체 수명 동안 항상 동일한 참조 '객체'를 유지할 수 있다.
  * **재렌더링 방지**: `.current`의 값이 바뀌더라도 `useState`와 달리 컴포넌트가 재렌더링되지 않는다. 렌더링에 영향을 주지 않는 값을 저장할 때 유용하다.


  <div style="margin-top:100px;"></div>

### 2.2. 동작 원리 3단계

`myRef.current`가 실제 DOM 요소를 가리키기까지의 과정은 3단계로 나눌 수 있다.

  * **1단계: 참조 객체(빈 상자) 생성**
    `useRef(null)`을 호출하여 `.current` 속성을 가진 참조 객체를 생성한다. 이 시점에서 `.current`는 초기값(`null`)을 가진다.

    ```javascript
    const emailRef = useRef(null); // { current: null }
    ```

  * **2단계: DOM 요소와 연결 (상자에 내용물 담기)**
    JSX의 `ref` 속성을 사용하여 React에게 렌더링될 DOM 요소를 `.current`에 담으라고 알려준다. React는 해당 DOM 요소가 마운트되면 `emailRef.current`에 해당 요소를 할당한다.

    ```jsx
    <input type="email" ref={emailRef} />
    ```

    이 과정이 끝나면 `emailRef` 객체는 다음과 같은 상태가 된다.
    `emailRef = { current: <input> DOM 엘리먼트 }`

  * **3단계: 필요할 때 사용 (상자 안의 내용물 사용)**
    이제 `emailRef.current`를 통해 실제 `<input>` DOM 요소에 접근하여, 해당 요소가 가진 고유한 메서드(`.focus()`, `.blur()` 등)를 호출하거나 속성을 읽을 수 있다.

    ```javascript
    const handleFocus = () => {
      emailRef.current.focus();
    };
    ```

    <div style="margin-top:100px;"></div>

| 용어               | 의미                                                 | 비유            |
| ------------------ | ---------------------------------------------------- | --------------- |
| `emailRef`         | React가 관리하는 참조 '객체'                         | 상자            |
| `emailRef.current` | 그 객체가 실제로 가리키는 '값' (DOM 엘리먼트 등)     | 상자 안의 내용물 |
| **기준** | **React는 ref 객체 자체는 불변으로 유지하고, 그 안의 `.current` 값만 변경하는 방식으로 동작한다.** | **상자는 그대로 두고 내용물만 바꾼다.** |

-----


<div style="margin-top:100px;"></div>

## 3. 참조 대상의 확장: 단일 요소에서 다중 요소로

`.current`는 기본적으로 하나의 대상을 지정하지만, 초기값을 어떻게 설정하고 `ref` 속성을 어떻게 사용하느냐에 따라 여러 대상을 관리할 수도 있다.

<div style="margin-top:100px;"></div>

### 3.1. 단일 요소 참조 (기본)

가장 일반적인 사용법으로, `.current`는 `null` 또는 단일 DOM 요소를 가진다.

```javascript
const mySingleRef = useRef(null);
// ...
<div ref={mySingleRef} />
```


<div style="margin-top:100px;"></div>

### 3.2. 다중 요소 참조 (응용)

여러 개의 동적 요소를 하나의 ref로 관리해야 할 경우, **`useRef`를 배열로 초기화**하고 **콜백 ref(Callback Ref)** 패턴을 사용한다.

  * **1단계: Ref를 빈 배열로 초기화**
    `.current`가 배열이 되도록 `useRef`의 초기값으로 `[]`를 전달한다. 이 배열이 여러 DOM 요소를 담을 '창고'가 된다.

    ```javascript
    const itemRefs = useRef([]);
    ```

  * **2단계: 콜백 Ref로 배열에 요소 추가**
    `ref` 속성에 ref 객체 대신 **함수**를 전달할 수 있다. 이를 '콜백 ref'라고 한다. 이 함수는 해당 DOM 요소가 마운트될 때 요소 자체를 인자로 받아 호출된다. 이 원리를 이용해 `.current` 배열에 각 요소를 추가한다.

    ```jsx
    {items.map((item, index) => (
      <div
        key={item.id}
        /*
         * 1. <div>가 렌더링될 때마다 이 함수가 호출된다.
         * 2. 인자 'el'은 방금 렌더링된 <div> DOM 요소를 가리킨다.
         * 3. itemRefs.current 배열의 index 위치에 해당 요소를 저장한다.
         */
        ref={(el) => (itemRefs.current[index] = el)}
      >
        {item.name}
      </div>
    ))}
    ```

  * **3단계: 배열 인덱스로 특정 요소에 접근**
    이제 `itemRefs.current`는 모든 `<div>` 요소를 순서대로 담은 배열이 된다. 인덱스를 통해 특정 요소에 접근하여 제어할 수 있다.

    ```javascript
    const handleScrollToItem = (index) => {
      // itemRefs.current는 [<div>, <div>, <div>, ...] 형태의 배열이다.
      itemRefs.current[index]?.scrollIntoView({ behavior: 'smooth' });
    };
    ```

    <div style="margin-top:100px;"></div>

이처럼 `.current`가 무엇을 담을지는 초기화 값에 따라 결정되며, 다중 요소를 관리할 때는 배열로 초기화하는 유연성을 발휘할 수 있다.