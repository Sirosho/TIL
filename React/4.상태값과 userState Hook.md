# **React의 상태 (State)**

## **개념**

\*\*상태(State)\*\*는 컴포넌트 **내부에서 관리되며 시간에 따라 변할 수 있는 데이터이다.** 사용자의 입력이나 API 응답 등이 상태에 해당한다. React의 가장 중요한 특징 중 하나로, **상태가 변경되면 컴포넌트는 자동으로 리렌더링(re-rendering)되어 화면이 업데이트된다.**

-----

## **useState 훅**

함수형 컴포넌트에서는 `useState` 훅(Hook)을 사용하여 상태를 관리한다. `useState`는 다음 두 가지 요소를 배열 형태로 반환한다.

1.  **상태 변수**: 현재 상태 값을 저장하는 변수
2.  **Setter 함수**: 해당 상태 값을 변경(갱신)하는 함수

<!-- end list -->

```jsx
const [state, setState] = useState(초기값);
```

-----

## **상태의 불변성과 Setter 함수 사용 이유**

React에서 상태를 다룰 때 \*\*불변성(immutability)\*\*을 지키는 것은 매우 중요하다. 즉, 상태 변수를 직접 수정해서는 안 된다.

상태를 변경할 때는 반드시 **Setter 함수를 사용해야 한다.**

  * **이유**: React는 **Setter 함수가 호출되는 것을 감지**하여 상태 변경을 인지하고, 컴포넌트를 리렌더링하는 프로세스를 시작한다. 만약 상태 변수를 직접 변경하면(예: `count++`), React는 변화를 감지하지 못해 UI가 업데이트되지 않는다. Setter 함수를 사용하는 것은 React에게 \*\*"상태가 바뀌었으니 화면을 다시 그려줘\!"\*\*라고 알려주는 신호와 같다.

-----

### **동작 예시: 클릭 카운터**

버튼을 클릭하면 숫자가 올라가는 카운터 예시이다.

```jsx
import React, { useState } from 'react';

function ClickCounter() {
    // 'count' 상태의 초기값을 0으로 설정한다.
    const [count, setCount] = useState(0);

    const handleClick = () => {  
        // Setter 함수를 통해 상태를 갱신 -> React가 리렌더링을 촉발한다.
        setCount(count + 1); 
    }

    return (
        <div>
            <button onClick={handleClick}>Click me!</button>
            <p>You clicked {count} times</p>
        </div>
    );
}
```

사용자가 버튼을 클릭하면 `handleClick` 함수가 실행되고, 내부의 `setCount`가 호출된다. React는 이 호출을 통해 `count` 상태의 변경을 감지하고, 새로운 `count` 값을 화면에 표시하기 위해 `ClickCounter` 컴포넌트를 리렌더링한다.

-----

# **중요: 상태와 렌더링의 관계**

Setter 함수(예: `setCount`)가 호출되면, React는 **무조건 컴포넌트를 리렌더링한다.** 하지만, 만약 `count`와 같은 상태 변수가 `return` 문의 JSX 코드에 포함되어 있지 않다면, 리렌더링이 발생하더라도 **화면에는 아무런 시각적 변화가 나타나지 않는다.**

상태 값은 내부적으로는 분명히 변경되어 있지만, 그 값을 화면에 표시하라는 코드가 없기 때문이다. 이는 마치 스프레드시트의 특정 셀(A1) 값을 변경했지만, 그 셀을 참조하는 차트나 다른 셀이 없는 것과 같다. 값은 바뀌었지만, 그 변화가 어디에도 보이지 않는 것이다.

따라서 상태의 변경을 UI에 반영하려면, 해당 상태 변수는 반드시 **`return` 문의 JSX 내부에서 사용되어야 한다.**