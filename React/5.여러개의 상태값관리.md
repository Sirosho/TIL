
## **React 상태 관리: 단일 값 vs. 객체**

### **상태 관리 방식**

React에서 컴포넌트의 상태를 관리하는 방식은 크게 두 가지로 나뉜다.

1.  **단일 값 상태**: 상태의 각 부분을 개별 `useState` 훅으로 분리하여 관리하는 방식이다.
    ```jsx
    const [title, setTitle] = useState('');
    const [price, setPrice] = useState('');
    ```
2.  **객체 상태**: 관련된 여러 상태를 하나의 객체로 묶어 단일 `useState` 훅으로 관리하는 방식이다.
    ```jsx
    const [userInput, setUserInput] = useState({ title: '', price: '' });
    ```

-----

### **객체 상태 업데이트와 불변성**

객체 형태의 상태를 업데이트할 때는 \*\*불변성(immutability)\*\*을 반드시 지켜야 한다. 즉, 기존 상태 객체를 직접 수정하면 안 된다.

대신, 스프레드 연산자(`...`)를 사용해 기존 객체의 모든 값을 복사한 **새로운 객체**를 생성하고, 그 안에서 변경할 속성만 덮어쓰는 방식으로 상태를 갱신해야 한다. 이 방식은 React가 상태 변경을 효과적으로 감지하고 리렌더링을 수행하게 하는 핵심 원리이다.

```jsx
setUserInput({
  ...userInput,
  enteredTitle: e.target.value
});
```

-----

### **중요: 상태 업데이트의 비동기적 특징과 해결책**

React의 상태 업데이트는 **비동기적으로 처리된다.** 이는 `setState` 함수 호출 직후에 상태 값이 즉시 바뀌는 것이 아님을 의미한다.

  * **문제점**: 이전 상태 값에 의존하는 여러 업데이트를 연속으로 호출할 경우, 아직 갱신되지 않은 예전 상태를 참조하여 의도치 않게 업데이트가 누락될 수 있다.

    ```jsx
    // 잘못된 예시: title 업데이트가 price 업데이트에 의해 덮어씌워질 수 있다.
    setUserInput({ ...userInput, enteredTitle: 'A' });
    setUserInput({ ...userInput, enteredPrice: 'B' }); // 여기서의 userInput은 아직 title이 'A'로 바뀌기 전의 상태일 수 있다.
    ```

  * **해결책**: Setter 함수에 값을 직접 전달하는 대신, **이전 상태(previous state)를 인자로 받는 함수를 전달한다.** 이를 **함수형 업데이트**라고 한다.

    ```jsx
    // 올바른 예시: React가 항상 최신 상태를 기준으로 다음 상태를 계산한다.
    setUserInput((prevState) => {
      return { ...prevState, enteredTitle: e.target.value };
    });
    ```

이 방식을 사용하면 React는 상태 업데이트를 순서대로 안전하게 처리하여 업데이트의 안정성을 보장한다. 특히 **이전 상태를 기반으로 다음 상태를 결정해야 할 때 이 방법은 필수적이다.**



## React에서 스프레드 문법이 중요한 이유: **불변성**

React는 상태(state)가 변경되었는지 판단할 때, 객체나 배열의 **참조값(메모리 주소)이 바뀌었는지**를 확인한다.

  * **직접 수정 (나쁜 예)**: `user.age = 31;` 또는 `fruits.push('키위');` 와 같은 방식은 내용물만 바꿀 뿐, 참조값은 그대로이다. 따라서 React는 변화를 알아차리지 못하고 **리렌더링을 하지 않는다.**
  * **스프레드 문법 (좋은 예)**: `{ ...user, age: 31 }` 또는 `[...fruits, '키위']` 는 항상 **새로운 참조값을 가진 새로운 객체/배열**을 만든다. React는 참조값이 바뀐 것을 보고 변화를 즉시 감지하여 **리렌더링을 수행한다.**

결론적으로 스프레드 문법은 \*\*"원본은 그대로 두고, 복사본을 만들어 수정한다"\*\*는 불변성의 원칙을 가장 쉽고 간결하게 지킬 수 있게 해주는 핵심 도구이다.





네, 스프레드 문법에 대한 상세 설명을 `~한다`, `~이다` 문체에 맞춰 마크다운 형식으로 정리해 드리겠습니다.

-----

## **스프레드 문법(...) 상세 설명**

스프레드 문법의 핵심 개념은 \*\*'포장을 풀어서 내용물만 꺼낸다'\*\*이다. 객체나 배열 같은 묶음(포장)을 풀어서 그 안에 있는 알맹이(값)들만 펼쳐놓는 역할을 한다.

-----

##  1. 객체와 함께 사용할 때

객체와 함께 쓰일 때 스프레드 문법은 그 객체가 가진 모든 key-value 쌍을 꺼내서 펼쳐준다.

###  객체 복사 (Shallow Copy)

가장 기본적인 사용법으로, 기존 객체와 똑같은 내용물을 가진 **새로운 객체**를 만들 때 사용한다.

  * **상황**: `user` 객체는 그대로 둔 채, 똑같은 내용의 `copiedUser` 객체를 만들고 싶을 때이다.
  * **코드**:
    ```javascript
    const user = { name: '홍길동', age: 30 };

    // user 객체의 내용물을 펼쳐서 새로운 객체 {} 안에 넣는다.
    const copiedUser = { ...user };

    console.log(copiedUser); // { name: '홍길동', age: 30 }
    console.log(user === copiedUser); // false (내용은 같지만, 완전히 다른 객체이다)
    ```

### 객체 병합 (Merging)

여러 개의 객체를 하나의 새로운 객체로 합칠 수 있다.

  * **상황**: 기본 정보가 담긴 객체와 상세 정보가 담긴 객체를 합쳐 완전한 프로필 객체를 만들고 싶을 때이다.
  * **코드**:
    ```javascript
    const basicInfo = { name: '홍길동' };
    const detailInfo = { age: 30, city: '서울' };

    const profile = { ...basicInfo, ...detailInfo };

    console.log(profile); // { name: '홍길동', age: 30, city: '서울' }
    ```
    **주의**: 만약 합치는 객체들에 동일한 key가 있다면, **가장 마지막에 오는 객체의 값**이 이전 값을 덮어쓴다.

### 객체 속성 수정 및 추가 (Updating & Adding)

**React에서 가장 중요하게 사용되는 방식**이다. 기존 객체를 복사하면서 동시에 특정 값을 바꾸거나 새로운 값을 추가한다.

  * **상황**: `user` 객체의 `age`는 바꾸고, `email`은 새로 추가하고 싶을 때이다.
  * **코드**:
    ```javascript
    const user = { name: '홍길동', age: 30 };

    const updatedUser = {
      ...user, // 1. user 객체의 내용물을 일단 모두 복사한다.
      age: 31, // 2. 복사된 내용 중 age 값을 31로 덮어쓴다.
      email: 'hong@example.com' // 3. email 속성을 새로 추가한다.
    };

    console.log(updatedUser); // { name: '홍길동', age: 31, email: 'hong@example.com' }
    ```

-----

## 2. 배열과 함께 사용할 때

배열과 함께 쓰일 때는 배열의 각 요소를 꺼내서 펼쳐준다.

### 배열 복사

객체와 마찬가지로, 내용물이 똑같은 **새로운 배열**을 만든다.

  * **코드**:
    ```javascript
    const fruits = ['사과', '바나나'];
    const copiedFruits = [...fruits];

    console.log(copiedFruits); // ['사과', '바나나']
    console.log(fruits === copiedFruits); // false (서로 다른 배열이다)
    ```

### 배열 병합 (Concatenating)

여러 배열을 합쳐 새로운 배열을 만든다.

  * **코드**:
    ```javascript
    const fruits = ['사과', '바나나'];
    const moreFruits = ['딸기', '포도'];

    const allFruits = [...fruits, ...moreFruits];

    console.log(allFruits); // ['사과', '바나나', '딸기', '포도']
    ```

### 요소 추가

기존 배열에 새로운 요소를 추가한 **새로운 배열**을 만든다. React에서 `push()` 대신 이 방법을 써야 한다.

  * **코드**:
    ```javascript
    const fruits = ['사과', '바나나'];

    // 맨 뒤에 추가
    const fruitsWithKiwi = [...fruits, '키위'];
    console.log(fruitsWithKiwi); // ['사과', '바나나', '키위']

    // 맨 앞에 추가
    const fruitsWithGrape = ['포도', ...fruits];
    console.log(fruitsWithGrape); // ['포도', '사과', '바나나']
    ```