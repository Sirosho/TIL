
#  createBrowserRouter


## `createBrowserRouter`란?

`createBrowserRouter`는 웹 애플리케이션의 라우팅 구성을 객체 기반으로 정의하는 함수이다. URL 주소와 해당 주소에 렌더링될 컴포넌트를 매핑하는 역할을 한다.

---

### 기본 구조

`createBrowserRouter`는 라우트 객체의 배열을 인자로 받는다.

```javascript
import { createBrowserRouter } from "react-router-dom";

const router = createBrowserRouter([
  {
    path: '/',
    element: <Layout />,
    children: [
      {
        path: 'about',
        element: <About />
      }
    ],
    errorElement: <ErrorPage />
  }
]);
````

  * **`path`**: 라우트의 URL 경로를 정의한다.
  * **`element`**: 해당 `path`에 접근했을 때 렌더링될 React 엘리먼트이다.
  * **`children`**: 중첩된 하위 라우트를 배열 형태로 정의한다. 부모 라우트의 `element` 내부에 렌더링된다.
  * **`errorElement`**: 라우트 로딩 또는 렌더링 중 에러가 발생했을 때 표시할 엘리먼트이다.

-----

### 주요 기능

#### 1\. 중첩 라우팅 (children)

`children` 속성을 사용하여 계층적인 라우트 구조를 생성할 수 있다.

```javascript
{
  path: '/mall',
  element: <MallLayout />,
  children: [
    {
      path: 'shops',
      element: <ShopList />,
      children: [
        {
          path: 'food',
          element: <FoodCourt />
        }
      ]
    }
  ]
}
```

#### 2\. 에러 처리 (errorElement)

`errorElement`는 라우트 경로에 문제가 발생했을 때 렌더링될 컴포넌트를 지정한다.

```javascript
{
  path: '*', // 존재하지 않는 모든 경로
  errorElement: <ErrorPage />
}
```

#### 3\. 데이터 로딩 (loader)

`loader` 함수는 컴포넌트가 렌더링되기 전에 필요한 데이터를 미리 로드하는 역할을 한다.

```javascript
{
  path: '/products/:id',
  element: <ProductDetail />,
  loader: async ({ params }) => {
    return fetchProduct(params.id);
  }
}
```

#### 4\. 데이터 변경 (action)

`action` 함수는 폼(Form) 제출과 같은 이벤트 발생 시 서버의 데이터를 변경하는 작업을 처리한다.

```javascript
{
  path: '/order',
  element: <OrderPage />,
  action: async ({ request }) => {
    const formData = await request.formData();
    return submitOrder(formData);
  }
}
```

-----

### 정리

`createBrowserRouter`의 특징은 다음과 같다.

  * 웹사이트의 전체 라우팅 구조를 중앙에서 명확하게 정의한다.
  * 중첩 라우팅을 통해 복잡한 페이지 구조를 효율적으로 관리할 수 있다.
  * `errorElement`를 통해 라우팅 관련 에러를 선언적으로 처리한다.
  * `loader`와 `action`을 사용하여 데이터 로딩 및 변경 로직을 체계적으로 관리한다.


# `createBrowserRouter` URL 조합 및 Index Route

---

### 개념

`createBrowserRouter`의 URL 경로는 계층적으로 구성된다. `children` 속성은 상위 경로에 종속되는 하위 경로를 정의하는 데 사용된다.

---

### 예시 구성

아래는 중첩된 라우트 구성을 나타내는 예시 코드이다.

```javascript
import { createBrowserRouter } from "react-router-dom";

const router = createBrowserRouter([
  {
    path: '/dashboard',
    element: <DashboardLayout />,
    children: [
      {
        index: true,
        element: <Summary />
      },
      {
        path: 'profile',
        element: <Profile />
      }
    ]
  }
]);
````

-----

### URL 조합 결과

| 부모 경로 | 자식 경로 | 완성된 URL | 렌더링 엘리먼트 |
| :--- | :--- | :--- | :--- |
| `/dashboard` | (없음) | `/dashboard` | `<Summary />` |
| `/dashboard` | `profile`| `/dashboard/profile`| `<Profile />` |

-----

### 핵심 개념

  * **URL 조합**: 자식 라우트의 `path`는 부모의 `path`에 이어 붙여져 완전한 URL을 형성한다.
  * **`index` 라우트**: `index: true`로 설정된 라우트는 부모의 URL 경로와 정확히 일치할 때 렌더링될 기본 자식 엘리먼트를 지정한다.
  * **`Outlet` 컴포넌트**: 부모 라우트의 엘리먼트 내에서 자식 라우트의 엘리먼트가 렌더링될 위치를 결정하는 역할을 한다.



<div style="margin-top:100px;"></div>



# 2.3 레이아웃 구성


## 레이아웃의 개념

\*\*레이아웃(Layout)\*\*은 웹사이트의 여러 페이지에 걸쳐 공통적으로 나타나는 UI 구조를 의미한다. 일반적으로 헤더(Header), 푸터(Footer), 내비게이션(Navigation) 등이 레이아웃에 포함되며, 각 페이지의 고유한 콘텐츠는 레이아웃 내부의 특정 영역에 표시된다.

이러한 패턴은 코드의 중복을 줄이고 애플리케이션 전체의 일관성을 유지하며, 유지보수를 용이하게 한다.

-----

## `Outlet` 컴포넌트와 `children` 속성

React Router에서 레이아웃을 구현하기 위해 **`Outlet`** 컴포넌트와 **`children`** 라우트 속성을 사용한다.

  * **`children`**: `createBrowserRouter`의 라우트 객체에서 특정 경로의 하위 경로들을 정의한다. 여기에 속한 자식 라우트들은 부모 라우트의 `element`를 공유한다.
  * **`Outlet`**: 부모 라우트의 컴포넌트 내에서 자식 라우트의 컴포넌트가 렌더링될 위치를 지정하는 역할을 한다.

-----

## 레이아웃 구현 방법

### 1\. 레이아웃 컴포넌트 생성

공통 UI 구조를 포함하고, 페이지별 콘텐츠가 표시될 위치에 `Outlet` 컴포넌트를 사용하는 레이아웃 컴포넌트를 생성한다.

```javascript
// /layouts/RootLayout.js
import { Outlet } from 'react-router-dom';
import Header from '../components/Header';
import Footer from '../components/Footer';

function RootLayout() {
  return (
    <>
      <Header />
      <main>
        <Outlet />
      </main>
      <Footer />
    </>
  );
}

export default RootLayout;
```

### 2\. 라우터에 레이아웃 적용

`createBrowserRouter`에서 부모 라우트의 `element`로 레이아웃 컴포넌트를 지정하고, 해당 레이아웃을 공유할 페이지들을 `children` 배열 안에 정의한다.

```javascript
const router = createBrowserRouter([
  {
    path: '/',
    element: <RootLayout />, // 최상위 경로에 레이아웃 적용
    children: [
      // RootLayout을 공유하는 페이지들
      {
        index: true,
        element: <HomePage />
      },
      {
        path: '/about',
        element: <AboutPage />
      }
    ]
  }
]);
```

-----

### 중첩 레이아웃

레이아웃은 중첩하여 사용할 수 있다. 예를 들어, 일반 사용자용 레이아웃과 관리자 페이지용 레이아웃을 별도로 구성하고 적용하는 것이 가능하다.

```javascript
const router = createBrowserRouter([
  {
    path: '/',
    element: <RootLayout />, // 모든 페이지에 적용되는 기본 레이아웃
    children: [
      { index: true, element: <HomePage /> },
      {
        path: 'admin',
        element: <AdminLayout />, // 관리자 섹션에만 적용되는 추가 레이아웃
        children: [
          { path: 'users', element: <UserManagement /> },
          { path: 'posts', element: <PostManagement /> }
        ]
      }
    ]
  }
]);
```

이 구조에서 `/admin/users` 경로는 `<RootLayout>` 내부에 `<AdminLayout>`이 렌더링되고, 그 내부에 `<UserManagement>`가 렌더링되는 중첩 구조를 갖는다.

-----

### 정리

  * 레이아웃은 반복되는 UI 구조를 단일 컴포넌트로 관리하는 디자인 패턴이다.
  * React Router에서는 부모 라우트의 `element`와 `children` 속성, 그리고 `Outlet` 컴포넌트를 통해 레이아웃을 구현한다.
  * 레이아웃을 중첩하여 더 복잡하고 세분화된 페이지 구조를 효율적으로 관리할 수 있다.



<div style="margin-top:100px;"></div>


# Link와 NavLink를 이용한 페이지 이동


## `Link` 컴포넌트

`Link`는 React Router에서 페이지 간 이동을 구현하는 핵심 컴포넌트이다.

## `<a>` 태그의 한계점

표준 HTML의 `<a>` 태그는 페이지를 완전히 새로고침(reload)하는 방식으로 동작한다. 이 방식은 단일 페이지 애플리케이션(SPA)에서 다음과 같은 문제를 유발한다.

  * 페이지 새로고침으로 인해 애플리케이션의 상태(state)가 모두 초기화된다.
  * 전체 페이지를 다시 로드하므로 사용자 경험이 저하된다.

이러한 문제를 해결하기 위해 React Router는 `Link` 컴포넌트를 제공한다. `Link`는 페이지를 새로고침하지 않고, 브라우저의 History API를 통해 주소만 변경하여 클라이언트 사이드 렌더링을 수행한다.

```javascript
import { Link } from 'react-router-dom';

function Navigation() {
  return (
    <div>
      <Link to="/">홈</Link>
      <Link to="/about">소개</Link>
    </div>
  );
}
```

-----

## `NavLink` 컴포넌트

`NavLink`는 `Link`의 특별한 버전으로, 주로 내비게이션 메뉴를 구성할 때 사용된다. 현재 활성화된 경로에 특정 스타일이나 클래스를 적용하는 기능을 내장하고 있다.

`NavLink`는 `className`이나 `style` 속성에 함수를 전달할 수 있다. 이 함수는 `{ isActive, isPending }` 객체를 인자로 받아, 상태에 따라 다른 값을 반환하도록 구현한다.

  * **`isActive`**: 현재 URL이 해당 링크의 경로와 일치할 경우 `true`가 된다.
  * **`isPending`**: 해당 경로로의 전환이 시작되었지만 아직 완료되지 않은 상태일 때 `true`가 된다.

<!-- end list -->

```javascript
import { NavLink } from 'react-router-dom';

function Navigation() {
  return (
    <nav>
      <NavLink
        to="/"
        className={({ isActive }) => isActive ? "active-class" : ""}
      >
        홈
      </NavLink>
      <NavLink
        to="/about"
        className={({ isActive }) => isActive ? "active-class" : ""}
      >
        소개
      </NavLink>
    </nav>
  );
}
```

-----

## `Link`와 `NavLink`의 사용 사례

| 구분 | `Link` | `NavLink` |
| :--- | :--- | :--- |
| **주요 목적** | 일반적인 페이지 이동 | 현재 위치를 표시해야 하는 내비게이션 |
| **사용 예시** | • 게시글 목록에서 상세 페이지로 이동\<br\>• "더 알아보기" 버튼 | • 상단 헤더 메뉴\<br\>• 사이드바 메뉴\<br\>• 탭(Tab) UI |

-----

### 정리

  * \*\*`Link`\*\*는 페이지 새로고침 없이 URL을 변경하고 컴포넌트를 렌더링하는 기본적인 이동 컴포넌트이다.
  * \*\*`NavLink`\*\*는 `Link`의 기능을 모두 포함하며, 현재 활성화된 경로를 시각적으로 구분해야 할 때 사용하는 특화된 컴포넌트이다.
  * 상황에 따라 적절한 컴포넌트를 선택하여 사용자 경험을 향상시킬 수 있다.





<div style="margin-top:100px;"></div>



# 에러 페이지 처리 (`errorElement`)



## 404 페이지의 개념

**404 페이지**는 사용자가 존재하지 않거나 접근할 수 없는 URL 경로로 진입했을 때, 해당 페이지를 찾을 수 없음을 안내하는 페이지이다. 이는 사용자 경험을 개선하고 웹사이트의 이탈률을 줄이는 데 중요한 역할을 한다.

-----

## `errorElement` 속성

React Router에서 라우팅 과정 중 발생하는 에러를 처리하기 위해 `errorElement` 속성을 사용한다. 이 속성에 지정된 React 엘리먼트는 해당 라우트 경로 및 그 하위 경로에서 에러가 발생했을 때 렌더링된다.

```javascript
const router = createBrowserRouter([
  {
    path: '/',
    element: <RootLayout />,
    errorElement: <ErrorPage />, // 에러 발생 시 렌더링될 엘리먼트
    children: [
      // ... 자식 라우트들
    ]
  }
]);
```



## `useRouteError` 훅

에러 페이지 컴포넌트 내에서는 `useRouteError` 훅을 사용하여 발생한 에러 객체에 접근할 수 있다. 이 객체에는 에러 상태 코드(`status`), 메시지(`message`), 스택 트레이스(`stack`) 등의 정보가 포함되어 있어, 에러 유형에 따른 동적인 UI 처리가 가능하다.

```javascript
import { useRouteError, Link } from 'react-router-dom';

function ErrorPage() {
  const error = useRouteError(); // 발생한 에러 객체를 반환한다.

  let title = "에러 발생";
  let message = "알 수 없는 문제가 발생했습니다.";

  if (error.status === 404) {
    title = "페이지를 찾을 수 없음 (404)";
    message = "요청하신 페이지가 존재하지 않습니다.";
  } else if (error.status === 500) {
    title = "서버 에러 (500)";
    message = "서버 내부에서 문제가 발생했습니다.";
  }

  return (
    <div>
      <h1>{title}</h1>
      <p>{message}</p>
      <Link to="/">홈으로 돌아가기</Link>
    </div>
  );
}
```

-----

## 에러 처리 범위 (버블링)

`errorElement`는 중첩된 라우트 구조에서 **버블링(bubbling)** 방식으로 동작한다. 자식 라우트에서 에러가 발생하면, React Router는 해당 라우트에 `errorElement`가 있는지 확인한다. 만약 없다면, 가장 가까운 상위(부모) 라우트의 `errorElement`를 찾아 올라가며 렌더링할 에러 페이지를 결정한다.

이를 통해 전역 에러 페이지와 특정 섹션에 대한 지역 에러 페이지를 구분하여 설정할 수 있다.

```javascript
const router = createBrowserRouter([
  {
    path: '/',
    element: <RootLayout />,
    errorElement: <ErrorPage />, // 전역 에러 페이지
    children: [
      {
        path: 'admin',
        element: <AdminLayout />,
        errorElement: <AdminErrorPage />, // admin 경로와 그 하위에서만 적용되는 에러 페이지
        children: [/*...*/]
      }
    ]
  }
]);
```

-----

### 정리

  * \*\*`errorElement`\*\*는 라우팅 에러 발생 시 사용자에게 보여줄 UI를 지정하는 속성이다.
  * **`useRouteError`** 훅을 사용하면 에러 객체에 접근하여 상세한 에러 정보를 활용할 수 있다.
  * 라우트 계층 구조를 이용하여 전역 에러 처리와 특정 경로에 대한 지역적 에러 처리를 모두 구현하는 것이 가능하다.