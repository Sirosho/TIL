# React의 부수 효과(Side Effect)와 `useEffect`


## 부수 효과(Side Effect)란?

\*\*부수 효과(Side Effect)\*\*는 함수가 자신의 범위(scope) 외부의 상태를 변경하거나 외부 상태에 의존할 때 발생하는 작업을 의미한다.

React 컴포넌트의 주된 책임은 UI를 렌더링하는 것이며, 그 외의 모든 작업은 부수 효과로 간주된다. 대표적인 예는 다음과 같다.

  * API를 통한 데이터 요청 및 구독(I/O 작업)
  * DOM을 직접 조작하는 작업
  * `setTimeout`이나 `setInterval` 같은 타이머 설정

-----

## 부수 효과 처리의 문제점: 무한 루프

컴포넌트의 렌더링 과정 중에 부수 효과를 직접 처리하면 예기치 않은 문제가 발생할 수 있으며, 대표적인 것이 무한 루프이다.

```javascript
import React, { useState } from 'react';

function App() {
  const [isLoggedIn, setIsLoggedIn] = useState(false);

  // 컴포넌트 렌더링 시마다 아래 로직이 실행된다.
  const storedUserLoggedInInformation = localStorage.getItem('isLoggedIn');

  if (storedUserLoggedInInformation === '1') {
    // 1. 상태를 변경하여 리렌더링을 유발한다.
    setIsLoggedIn(true); 
  }

  // ... loginHandler, logoutHandler
  
  // 2. 리렌더링되면 컴포넌트가 다시 실행되어 1번 과정을 반복한다.
  return (
    // ... JSX
  );
}
```

위 코드에서 `setIsLoggedIn` 함수는 컴포넌트의 상태를 변경하여 리렌더링을 유발한다. 리렌더링이 발생하면 컴포넌트 본문이 다시 실행되어 `localStorage`를 읽고 `setIsLoggedIn`을 재호출하는 과정이 반복되므로, 무한 루프에 빠지게 된다.

-----

## `useEffect`를 이용한 해결

\*\*`useEffect`\*\*는 React 컴포넌트의 렌더링이 완료된 후에 부수 효과를 실행하도록 하여 위와 같은 문제를 해결하는 훅(Hook)이다.

함수 컴포넌트에서는 `useEffect`를 사용하여, 클래스 컴포넌트의 생명주기 메서드(`componentDidMount`, `componentDidUpdate`, `componentWillUnmount`)에서 처리하던 부수 효과 관련 작업을 수행한다.

### `useEffect`의 구조와 동작

```javascript
useEffect(() => {
  // 1. 부수 효과(Side Effect)를 수행하는 코드를 작성한다.

  return () => {
    // 2. 뒷정리(cleanup) 코드를 작성한다. (선택 사항)
  };
}, [/* 3. 의존성 배열 */]);
```

1.  **Effect 함수**: `useEffect`의 첫 번째 인자로, 렌더링이 완료된 후 비동기적으로 실행된다. DOM 업데이트를 차단하지 않는다.

2.  **뒷정리(Cleanup) 함수**: Effect 함수가 반환하는 함수이다. 컴포넌트가 사라지기 전(unmount)이나, 다음 effect가 실행되기 직전에 호출된다. `setInterval` 해제, 이벤트 리스너 제거 등 리소스를 정리하는 데 사용된다.

3.  **의존성 배열(Dependency Array)**: `useEffect`의 두 번째 인자로, effect의 실행 시점을 결정한다.

      * **배열 생략**: 컴포넌트가 리렌더링될 때마다 effect가 실행된다.
      * **빈 배열 `[]`**: 컴포넌트가 최초 렌더링된 후 단 한 번만 effect가 실행된다.
      * **배열에 의존성 `[dep1, dep2]` 명시**: 최초 렌더링 시 그리고 배열 안의 의존성(상태 또는 props)이 변경되었을 때만 effect가 실행된다.



      <div style="margin-top:100px;"></div>



# React의 `useEffect` 훅과 의존성 배열


## `useEffect` 훅과 부수 효과(Side Effect)

`useEffect`는 React 컴포넌트 내에서 부수 효과를 처리하기 위한 빌트인(built-in) 훅이다. **부수 효과**란 데이터 fetching, 구독(subscription), DOM 수동 조작 등과 같이 컴포넌트의 주된 렌더링 작업 외에 발생하는 부가적인 효과를 의미한다.

`useEffect`는 실행할 effect 함수와 의존성 배열, 두 개의 인자를 받는다.

```javascript
useEffect(() => {
  // enteredEmail 또는 enteredPassword가 변경될 때마다 폼 유효성을 검사한다.
  setFormIsValid(
    enteredEmail.includes('@') && enteredPassword.trim().length > 6
  );
}, [enteredEmail, enteredPassword]);
```

-----

## 의존성 배열(Dependency Array)

**의존성 배열**은 `useEffect`에 전달된 effect 함수가 실행될 조건을 결정하는 역할을 한다. 배열 안에 명시된 값들 중 하나라도 변경될 때, effect 함수가 다시 호출된다. 이를 통해 불필요한 effect 실행을 방지하고 애플리케이션의 성능을 최적화할 수 있다.

```javascript
useEffect(() => {
  // 부수 효과
}, [dependency1, dependency2]);
```

위 예시에서 `dependency1` 또는 `dependency2`의 값이 이전 렌더링과 비교하여 변경되었을 경우에만 effect가 실행된다.

-----

## 의존성 배열 설정 규칙

`useEffect`의 동작은 의존성 배열의 설정 방식에 따라 결정된다.

1.  **배열에 의존성 명시**: `[dep1, dep2]`

      * **동작**: 명시된 의존성(`dep1` 또는 `dep2`) 중 하나라도 값이 변경되면 effect가 실행된다.
      * **고려사항**: effect 함수 내부에서 사용되는 모든 외부 상태(state)나 `props`는 의존성 배열에 포함하는 것이 원칙이다. 포함하지 않을 경우, 최신 값을 참조하지 못하는 문제가 발생할 수 있다.

2.  **빈 배열 전달**: `[]`

      * **동작**: effect 함수는 컴포넌트가 처음 렌더링될 때 **단 한 번만** 실행된다.
      * **고려사항**: 컴포넌트 마운트 시점에 한 번만 실행되어야 하는 초기화 작업(예: 최초 데이터 로딩)에 적합하다.

3.  **배열 생략**: `useEffect(() => { ... })`

      * **동작**: 컴포넌트가 **리렌더링될 때마다** effect가 실행된다.
      * **고려사항**: 의도치 않은 성능 저하나 무한 루프를 유발할 수 있어 사용에 주의가 필요하다.

-----

### 결론

`useEffect` 의존성 배열의 설정 기준은 \*\*"effect 함수가 어떤 외부 값에 의존하는가"\*\*이다.

  * effect가 특정 상태나 `props`에 의존한다면, 해당 값은 의존성 배열에 포함되어야 한다.
  * effect가 최초 한 번만 실행되어야 한다면, 빈 배열을 사용한다.
  * 리렌더링마다 실행되어야 한다면, 의존성 배열을 생략한다.

이 규칙들을 이해하고 적용하면 `useEffect`의 동작을 명확하게 제어할 수 있다.






<div style="margin-top:100px;"></div>

# `useEffect` 뒷정리(Cleanup) 함수

-----

## 뒷정리 함수의 역할과 목적

`useEffect`의 effect 함수가 반환하는 함수를 **뒷정리(Cleanup) 함수**라고 한다. 이 함수의 주된 역할은 컴포넌트가 사라지거나(unmount), effect가 다시 실행되기 직전에 이전에 설정된 부수 효과를 정리하는 것이다. 이를 통해 메모리 누수나 의도치 않은 동작을 방지할 수 있다.

```javascript
useEffect(() => {
  // 500ms 후에 입력값 유효성을 검증하는 타이머를 설정한다.
  const identifier = setTimeout(() => {
    console.log('입력값 검증 시작!');
    setFormIsValid(
      enteredEmail.includes('@') && enteredPassword.trim().length > 6
    );
  }, 500);

  // 뒷정리 함수
  return () => {
    // 다음 effect가 실행되기 직전에 이전 타이머를 취소한다.
    console.log('cleanup!!');
    clearTimeout(identifier);
  };
}, [enteredEmail, enteredPassword]);
```

위 예시에서 사용자가 빠르게 입력하면 의존성인 `enteredEmail` 또는 `enteredPassword`가 계속 변경된다. 변경될 때마다 새로운 `setTimeout`이 설정되기 전에, 뒷정리 함수가 실행되어 이전에 설정된 타이머를 `clearTimeout`으로 제거한다. 이로 인해 마지막 입력이 끝난 후에 단 한 번만 유효성 검사가 실행된다.

-----

## 디바운싱(Debouncing)과 스로틀링(Throttling)

디바운싱과 스로틀링은 연속적으로 발생하는 이벤트를 제어하여 성능을 최적화하는 대표적인 기법이다.

### 디바운싱 (Debouncing)

**디바운싱**은 연이어 발생하는 이벤트를 하나의 그룹으로 묶어, 마지막 이벤트가 발생한 후 일정 시간이 지났을 때 단 한 번만 처리하는 기법이다.

  * **동작 방식**: 이벤트가 발생하면 타이머를 설정하고, 설정된 시간 내에 동일한 이벤트가 다시 발생하면 기존 타이머를 취소하고 새로운 타이머를 설정한다.
  * **주요 사용 사례**:
      * 사용자 입력 유효성 검사 (입력이 끝난 후에 검사)
      * 검색어 자동 완성 (타이핑이 멈췄을 때 API 요청)
  * **예시 코드** (`lodash` 라이브러리 사용):
    ```javascript
    import { debounce } from 'lodash';

    // 300ms 동안 추가 입력이 없으면 onSearch 함수를 호출한다.
    const handleSearch = debounce((value) => {
      onSearch(value);
    }, 300);

    <input type="text" onChange={(e) => handleSearch(e.target.value)} />
    ```

### 스로틀링 (Throttling)

**스로틀링**은 이벤트가 연속적으로 발생하더라도, 일정한 시간 간격(예: 0.3초마다)으로 단 한 번씩만 이벤트를 처리하는 기법이다.

  * **동작 방식**: 이벤트가 발생하면 즉시 처리하고, 이후 일정 시간 동안은 발생하는 이벤트를 모두 무시한다.
  * **주요 사용 사례**:
      * 스크롤 이벤트 (무한 스크롤, 스크롤 위치에 따른 애니메이션)
      * 마우스 이동 이벤트 (커서 위치 추적)
  * **예시 코드** (`lodash` 라이브러리 사용):
    ```javascript
    import { throttle } from 'lodash';

    // 스크롤 이벤트가 아무리 많이 발생해도 300ms 간격으로 한 번만 처리된다.
    window.addEventListener('scroll', throttle(() => {
      console.log('스크롤 이벤트 처리');
    }, 300));
    ```