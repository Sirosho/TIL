# loader 함수 이해하기

## `loader`란?

\*\*`loader`\*\*는 React Router의 라우트 객체에 정의하는 함수로, 해당 경로의 컴포넌트가 렌더링되기 전에 필요한 데이터를 미리 가져오는(pre-fetching) 역할을 한다.

이러한 **"렌더링 전 데이터 로딩(fetch-before-render)"** 패턴은 사용자 경험을 향상시키고, 데이터 로딩과 관련된 로직을 컴포넌트로부터 분리하여 코드 구조를 개선한다.

-----

## `loader` 사용의 이점

  * **사용자 경험 개선**: 컴포넌트가 렌더링된 후 `useEffect`에서 데이터를 가져오는 방식은 필연적으로 로딩 상태(빈 화면, 스피너 등)를 노출시킨다. `loader`는 렌더링 이전에 데이터 준비를 완료하므로, 사용자는 데이터가 채워진 완전한 UI를 보게 된다.
  * **중앙화된 데이터 로직**: 데이터 로딩, 에러 처리, 조건부 리다이렉트 등의 로직을 라우트 설정 단계에서 중앙 관리할 수 있어 컴포넌트의 복잡도를 낮춘다.
  * **선언적 에러 처리**: `loader` 내에서 에러를 `throw`하면, React Router가 자동으로 가장 가까운 `errorElement`를 렌더링하여 선언적인 에러 처리가 가능하다.

-----

## 사용 방법

`loader` 함수는 라우트 객체 내에 정의하며, 항상 **Promise를 반환**해야 한다. `async/await` 문법 사용이 권장된다.

### 1\. 기본 `loader`

`loader` 함수는 `{ params, request }` 객체를 인자로 받는다. `params` 객체를 통해 URL의 동적 파라미터에 접근할 수 있다.

```javascript
const router = createBrowserRouter([
  {
    path: '/blog/:id',
    element: <BlogPost />,
    loader: async ({ params }) => {
      // params.id를 사용하여 특정 포스트 데이터를 가져온다.
      const post = await fetchPost(params.id);
      return post; // 반환된 데이터는 useLoaderData 훅으로 접근 가능하다.
    }
  }
]);
```

### 2\. 여러 데이터 동시 로딩

`Promise.all`을 사용하여 여러 API 요청을 병렬로 처리하고, 모든 데이터가 준비되었을 때 반환한다.

```javascript
const loader = async () => {
  const [posts, user] = await Promise.all([
    fetchPosts(),
    fetchUser()
  ]);
  return { posts, user };
};
```

### 3\. 조건부 리다이렉트

`loader` 내에서 특정 조건(예: 인증 상태)을 확인하고, `redirect` 유틸리티 함수를 `throw`하여 다른 페이지로 강제 이동시킬 수 있다.

```javascript
import { redirect } from 'react-router-dom';

const loader = async () => {
  const user = await checkUserAuth();
  if (!user) {
    // 인증되지 않은 사용자는 로그인 페이지로 리다이렉트한다.
    throw redirect('/login');
  }
  return user;
};
```

-----

## 실전 활용

### 로딩 상태 처리

페이지 전환 중 `loader`가 실행되는 동안의 로딩 상태는 `useNavigation` 훅으로 감지할 수 있다.

```javascript
import { useNavigation } from 'react-router-dom';

function SomePage() {
  const navigation = useNavigation();

  // navigation.state가 "loading"이면 로더가 실행 중인 상태이다.
  if (navigation.state === "loading") {
    return <LoadingSpinner />;
  }
  // ...
}
```

### HTTP 상태에 따른 에러 처리

`fetch` API의 `Response` 객체를 직접 `throw`하여 HTTP 상태 코드에 따른 구체적인 에러 처리를 구현할 수 있다.

```javascript
const loader = async () => {
  const response = await fetch('/api/non-existent-post');
  if (!response.ok) {
    throw new Response("데이터를 찾을 수 없습니다.", { status: 404 });
  }
  return response.json();
};
```

-----

## 주의사항

  * **비동기 처리**: `loader`는 항상 Promise를 반환해야 한다. 일반 객체나 값을 반환하더라도 React Router가 이를 Promise로 감싸서 처리한다.
  * **과도한 데이터 로딩**: 페이지 렌더링에 필수적인 데이터만 로딩해야 한다. 불필요한 데이터를 과도하게 로딩하면 초기 페이지 전환 속도가 저하될 수 있다.



<div style="margin-top:100px;"></div>


# useLoaderData로 데이터 사용하기


## `useLoaderData`란?

\*\*`useLoaderData`\*\*는 React Router가 제공하는 훅(Hook)으로, 현재 경로의 `loader` 함수가 반환한 데이터를 컴포넌트 내에서 접근할 수 있도록 한다.

`loader`가 데이터를 미리 준비하는 단계라면, `useLoaderData`는 준비된 데이터를 실제 UI 렌더링에 사용하는 단계이다.

-----

## 사용 방법

### 1\. 기본 사용법

라우트 설정에 정의된 `loader`가 반환한 값은 해당 라우트의 `element`로 지정된 컴포넌트에서 `useLoaderData`를 통해 그대로 받을 수 있다.

```javascript
// routes.jsx
const router = createBrowserRouter([
  {
    path: '/blog/:id',
    element: <BlogPost />,
    loader: async ({ params }) => {
      const post = await fetchPost(params.id);
      return post;
    }
  }
]);

// BlogPost.jsx
import { useLoaderData } from 'react-router-dom';

function BlogPost() {
  const post = useLoaderData(); // loader가 반환한 post 객체를 받는다.

  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </article>
  );
}
```

### 2\. 여러 데이터 사용하기

`loader`가 여러 데이터를 포함하는 객체를 반환한 경우, 컴포넌트에서는 구조 분해 할당을 사용하여 각 데이터에 쉽게 접근할 수 있다.

```javascript
// loader
const loader = async () => {
  return {
    posts: await fetchPosts(),
    user: await fetchUser()
  };
};

// 컴포넌트
function BlogPage() {
  const { posts, user } = useLoaderData();
  // ...
}
```

-----

## 주의사항

  * **사용 위치**: `useLoaderData`는 라우트 객체의 `element`로 지정된 컴포넌트 또는 그 하위(자식) 컴포넌트에서만 호출할 수 있다. 라우트와 관련 없는 컴포넌트에서 호출하면 에러가 발생한다.
  * **읽기 전용**: `useLoaderData`가 반환하는 데이터는 읽기 전용(read-only)이다. 데이터를 생성, 수정, 삭제하는 작업은 `action` 함수를 통해 처리해야 한다.
  * **타입 안정성**: TypeScript 사용 시, `loader` 함수의 반환 타입을 명시하고 `useLoaderData`의 제네릭 타입을 지정하면 데이터의 타입 안정성을 확보할 수 있다.

-----


<div style="margin-top:100px;"></div>


# `loader` 함수 아웃소싱

## `loader` 아웃소싱의 필요성

모든 `loader` 로직을 라우터 설정 파일에 직접 작성하면 파일이 비대해지고 코드의 관리가 어려워진다. `loader` 함수를 별도의 파일로 분리(아웃소싱)하면 코드의 구조화, 재사용성, 유지보수성을 높일 수 있다.

-----

<div style="margin-top:100px;"></div>



## `loader` 아웃소싱 방법

### 1\. 기능 단위로 분리

데이터 로딩 로직을 별도의 파일(`loaders/postLoader.js`)로 분리하여 `export`한다. 이후 라우터 설정 파일에서 해당 함수를 `import`하여 `loader` 속성에 할당한다.

```javascript
// loaders/postLoader.js
export async function postLoader({ params }) {
  const post = await fetchPost(params.id);
  if (!post) {
    throw new Response("Post Not Found", { status: 404 });
  }
  return post;
}

// routes.jsx
import { postLoader } from './loaders/postLoader';

const router = createBrowserRouter([
  {
    path: '/blog/:id',
    element: <BlogPost />,
    loader: postLoader // 분리된 loader 함수를 할당
  }
]);
```

### 2\. `loader` 전용 폴더 관리

애플리케이션이 복잡해지면 `loaders`라는 전용 폴더를 만들고, 기능별로 `loader` 파일을 생성하여 관리하는 것이 효율적이다. `index.js` 파일을 통해 모든 `loader`를 한 번에 `export`하여 사용 편의성을 높일 수 있다.

```
src/
 ├── pages/
 └── loaders/
     ├── blogLoader.js
     ├── userLoader.js
     └── index.js
```

```javascript
// loaders/index.js
export * from './blogLoader';
export * from './userLoader';
```

-----

## 아웃소싱의 장점

  * **코드 구조화**: 라우터 설정 파일은 경로와 컴포넌트 매핑에만 집중하게 되어 가독성이 향상된다.
  * **재사용성**: 동일한 데이터 로딩 로직이 필요한 여러 라우트에서 같은 `loader` 함수를 재사용할 수 있다.
  * **테스트 용이성**: `loader` 함수는 순수 JavaScript 함수에 가까우므로, UI 렌더링과 독립적으로 테스트하기가 용이하다.



<div style="margin-top:100px;"></div>





# `loader` vs `useEffect` 데이터 로딩 방식 비교



### 비교표

| 구분 | `loader` (React Router) | `useEffect` |
| :--- | :--- | :--- |
| **데이터 로딩 시점** | 컴포넌트가 **렌더링되기 전**, 라우트(경로) 진입 시 | 컴포넌트가 **최초 렌더링된 후** (Mount 시점) |
| **렌더링 패러다임** | **Fetch-then-Render** (데이터를 가져온 후 렌더링) | **Render-then-Fetch** (먼저 렌더링 후 데이터를 가져옴) |
| **데이터 접근** | `useLoaderData` 훅을 통해 데이터를 바로 사용 | `useState`로 상태(data, isLoading, error)를 만들고 직접 관리 |
| **로딩 상태 관리** | 라우터가 내부적으로 관리 (`useNavigation` 훅으로 상태 확인) | 개발자가 `isLoading` 같은 상태 변수를 만들어 직접 관리 |
| **사용자 경험 (UX)** | • 데이터가 준비된 완전한 페이지를 보게 됨<br>• 콘텐츠 깜빡임(flickering)이 적음<br>• 초기 페이지 전환이 약간 느리게 느껴질 수 있음 | • 스켈레톤 UI나 로딩 스피너를 먼저 보게 됨<br>• 초기 화면 진입은 빠르지만, 데이터 로딩으로 인한 화면 변화가 발생 |
| **주요 사용 사례** | • 페이지에 **필수적인 핵심 데이터**를 불러올 때<br>• 데이터가 없으면 의미 없는 페이지를 렌더링할 때 | • **부가적인 데이터**를 불러올 때 (예: 위젯)<br>• 사용자 상호작용(버튼 클릭 등)으로 데이터를 요청할 때 |
| **장점** | • 데이터 로딩과 뷰(View) 로직의 분리<br>• 컴포넌트 내 `useState`, `useEffect` 보일러플레이트 코드 감소<br>• 서버사이드 렌더링(SSR)과 자연스럽게 연동 | • React의 기본적인 훅이므로 사용이 간단하고 익숙함<br>• 어떤 컴포넌트에서든 자유롭게 사용 가능<br>• 라우팅 라이브러리에 종속되지 않음 |
| **단점** | • React Router 등 특정 라이브러리에 종속적<br>• 컴포넌트 외부(라우트 설정)에 로직이 위치하여 코드 추적이 번거로울 수 있음 | • 데이터 로딩 상태(isLoading, error 등)를 직접 관리해야 함<br>• 클라이언트-서버 간 요청 폭포(Request Waterfall) 문제 발생 가능성 |

---




<div style="margin-top:100px;"></div>



# 핵심 개념 요약

## 로더(Loader) 방식

"명시적으로 fetch를 받아서 렌더링한다"는 설명은 이 방식의 핵심을 나타낸다.

* **동작 순서**: **데이터 요청 → 요청 완료 → 렌더링**
* **특징**: 컴포넌트를 렌더링하기 전에 데이터 준비가 완료되어야 한다는 명확한 순서가 정의되어 있다.

---
## `useEffect` 방식

"특정 시점에 트리거를 지정하고 조건이 충족되면 렌더링한다"는 설명은 이 방식의 특징을 나타낸다.

* **동작 순서**: **우선 렌더링 → `useEffect` 트리거 발동 → 데이터 요청 → 요청 완료 → 재렌더링**
* **특징**: 우선 UI 골격을 먼저 렌더링하고, `useEffect`의 조건이 충족되면 데이터 요청을 시작하여 화면을 업데이트하는 방식이다.

두 방식 모두 데이터를 가져와 화면을 렌더링한다는 목표는 동일하지만, 그 **순서와 시점**에서 명확한 차이가 존재한다.