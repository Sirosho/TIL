# `loader` vs `useEffect` 데이터 로딩 방식 비교

React 애플리케이션에서 데이터를 가져오는 두 가지 주요 방식인 React Router의 `loader`와 React의 `useEffect` 훅의 개념적 차이를 정리합니다. 두 방식의 가장 핵심적인 차이는 **"데이터를 언제 가져오는가"**에 있습니다.

---

### 비교표

| 구분 | `loader` (React Router) | `useEffect` |
| :--- | :--- | :--- |
| **데이터 로딩 시점** | 컴포넌트가 **렌더링되기 전**, 라우트(경로) 진입 시 | 컴포넌트가 **최초 렌더링된 후** (Mount 시점) |
| **렌더링 패러다임** | **Fetch-then-Render** (데이터를 가져온 후 렌더링) | **Render-then-Fetch** (먼저 렌더링 후 데이터를 가져옴) |
| **데이터 접근** | `useLoaderData` 훅을 통해 데이터를 바로 사용 | `useState`로 상태(data, isLoading, error)를 만들고 직접 관리 |
| **로딩 상태 관리** | 라우터가 내부적으로 관리 (`useNavigation` 훅으로 상태 확인) | 개발자가 `isLoading` 같은 상태 변수를 만들어 직접 관리 |
| **사용자 경험 (UX)** | • 데이터가 준비된 완전한 페이지를 보게 됨<br>• 콘텐츠 깜빡임(flickering)이 적음<br>• 초기 페이지 전환이 약간 느리게 느껴질 수 있음 | • 스켈레톤 UI나 로딩 스피너를 먼저 보게 됨<br>• 초기 화면 진입은 빠르지만, 데이터 로딩으로 인한 화면 변화가 발생 |
| **주요 사용 사례** | • 페이지에 **필수적인 핵심 데이터**를 불러올 때<br>• 데이터가 없으면 의미 없는 페이지를 렌더링할 때 | • **부가적인 데이터**를 불러올 때 (예: 위젯)<br>• 사용자 상호작용(버튼 클릭 등)으로 데이터를 요청할 때 |
| **장점** | • 데이터 로딩과 뷰(View) 로직의 분리<br>• 컴포넌트 내 `useState`, `useEffect` 보일러플레이트 코드 감소<br>• 서버사이드 렌더링(SSR)과 자연스럽게 연동 | • React의 기본적인 훅이므로 사용이 간단하고 익숙함<br>• 어떤 컴포넌트에서든 자유롭게 사용 가능<br>• 라우팅 라이브러리에 종속되지 않음 |
| **단점** | • React Router 등 특정 라이브러리에 종속적<br>• 컴포넌트 외부(라우트 설정)에 로직이 위치하여 코드 추적이 번거로울 수 있음 | • 데이터 로딩 상태(isLoading, error 등)를 직접 관리해야 함<br>• 클라이언트-서버 간 요청 폭포(Request Waterfall) 문제 발생 가능성 |

---

### 핵심 개념 요약

* **`loader`**: **"어떤 데이터를 가지고 렌더링할까?"** 를 먼저 결정하는 방식입니다. 라우터가 목적지 페이지에 필요한 데이터를 미리 준비해서 "자, 이 데이터 가지고 렌더링해!" 하고 컴포넌트에 전달해주는 것과 같습니다. 이는 데이터 중심적인 접근 방식입니다.

* **`useEffect`**: **"언제 데이터를 가져올까?"** 를 컴포넌트의 생명주기에 맞춰 결정하는 방식입니다. 컴포넌트가 일단 화면에 나타난 뒤 "아, 이제 데이터를 가져와야겠다!" 하고 스스로 움직이는 것과 같습니다. 이는 컴포넌트 중심적인 접근 방식입니다.

따라서 페이지의 핵심 콘텐츠는 `loader`를 통해 가져와 사용자 경험을 향상시키고, 페이지 내에서 부가적으로 필요한 데이터나 사용자의 행동에 따라 필요한 데이터는 `useEffect`를 사용하는 등 두 가지 방식을 혼합하여 사용하는 것이 이상적입니다.