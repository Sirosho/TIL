# 객체 스프레드 문법 완전 가이드

## 1. 스프레드 문법이란?

스프레드 문법(`...`)은 **반복 가능한 객체의 요소들을 개별적으로 펼쳐주는 문법**입니다. ES6(ES2015)에서 배열용으로 도입되었고, ES2018에서 객체로 확장되었습니다.

```javascript
// 기본 개념
const obj = { a: 1, b: 2, c: 3 };
const newObj = { ...obj }; // obj의 모든 속성을 복사
console.log(newObj); // { a: 1, b: 2, c: 3 }
```

---

## 2. 객체 복사 (얕은 복사)

### 기존 방식 vs 스프레드 문법

```javascript
const original = { name: 'John', age: 30 };

// 기존 방식 (참조 복사 - 위험!)
const bad = original;
bad.age = 31;
console.log(original.age); // 31 (원본도 변경됨!)

// Object.assign 사용
const copy1 = Object.assign({}, original);

// 스프레드 문법 (권장!)
const copy2 = { ...original };
copy2.age = 31;
console.log(original.age); // 30 (원본 안전)
```

### 중요한 점: 얕은 복사
```javascript
const user = {
    name: 'Alice',
    address: {
        city: 'Seoul',
        district: 'Gangnam'
    }
};

const copied = { ...user };
copied.address.city = 'Busan';

console.log(user.address.city); // 'Busan' (중첩 객체는 참조가 복사됨!)
```

---

## 3. 객체 병합과 속성 추가

### 새로운 속성 추가
```javascript
const user = { name: 'Bob', age: 25 };

// 새 속성 추가
const userWithEmail = {
    ...user,
    email: 'bob@example.com'
};
console.log(userWithEmail);
// { name: 'Bob', age: 25, email: 'bob@example.com' }
```

### 여러 객체 병합
```javascript
const personal = { name: 'Charlie', age: 35 };
const contact = { email: 'charlie@email.com', phone: '123-456-7890' };
const work = { company: 'Tech Corp', position: 'Developer' };

const complete = {
    ...personal,
    ...contact,
    ...work
};

console.log(complete);
// {
//   name: 'Charlie',
//   age: 35,
//   email: 'charlie@email.com',
//   phone: '123-456-7890',
//   company: 'Tech Corp',
//   position: 'Developer'
// }
```

---

## 4. 속성 덮어쓰기 (우선순위)

### 순서가 중요합니다!
```javascript
const defaults = { theme: 'light', fontSize: 14, showSidebar: true };
const userPrefs = { theme: 'dark', fontSize: 16 };

// userPrefs가 defaults를 덮어씀
const config1 = { ...defaults, ...userPrefs };
console.log(config1);
// { theme: 'dark', fontSize: 16, showSidebar: true }

// defaults가 userPrefs를 덮어씀
const config2 = { ...userPrefs, ...defaults };
console.log(config2);
// { theme: 'light', fontSize: 14, showSidebar: true }

// 특정 속성만 덮어쓰기
const config3 = {
    ...defaults,
    ...userPrefs,
    fontSize: 18  // 최종적으로 18로 설정
};
console.log(config3);
// { theme: 'dark', fontSize: 18, showSidebar: true }
```

---

## 5. React에서의 실제 사용 예시

### State 업데이트
```javascript
const [user, setUser] = useState({
    name: 'John',
    email: 'john@email.com',
    preferences: {
        theme: 'light',
        notifications: true
    }
});

// 이름만 변경
const updateName = (newName) => {
    setUser({
        ...user,           // 기존 속성들 유지
        name: newName      // name만 변경
    });
};

// 중첩 객체 업데이트 (주의!)
const updateTheme = (newTheme) => {
    setUser({
        ...user,
        preferences: {
            ...user.preferences,  // 중첩 객체도 스프레드 필요!
            theme: newTheme
        }
    });
};
```

### Props 전달
```javascript
// 부모 컴포넌트
const ParentComponent = () => {
    const userInfo = {
        name: 'Alice',
        email: 'alice@example.com',
        age: 28
    };
    
    const additionalProps = {
        isVip: true,
        memberSince: '2020'
    };

    return (
        <ChildComponent 
            {...userInfo}        // 모든 userInfo 속성 전달
            {...additionalProps} // 추가 속성들도 전달
            customProp="special" // 개별 속성도 함께 전달 가능
        />
    );
};

// 자식 컴포넌트에서는 모든 속성을 개별적으로 받을 수 있음
const ChildComponent = ({ name, email, age, isVip, memberSince, customProp }) => {
    return <div>{name} ({email}) - VIP: {isVip}</div>;
};
```

---

## 6. 고급 패턴들

### 조건부 속성 추가
```javascript
const createUser = (name, email, isAdmin = false) => {
    return {
        name,
        email,
        createdAt: new Date(),
        ...(isAdmin && { role: 'admin', permissions: ['read', 'write', 'delete'] })
    };
};

console.log(createUser('John', 'john@email.com'));
// { name: 'John', email: 'john@email.com', createdAt: Date }

console.log(createUser('Admin', 'admin@email.com', true));
// { name: 'Admin', email: 'admin@email.com', createdAt: Date, role: 'admin', permissions: [...] }
```

### 속성 제거 (Rest 구문과 함께)
```javascript
const user = {
    name: 'Bob',
    email: 'bob@email.com',
    password: 'secret123',
    age: 30
};

// password 제거한 새 객체 생성
const { password, ...userWithoutPassword } = user;
console.log(userWithoutPassword);
// { name: 'Bob', email: 'bob@email.com', age: 30 }

// 여러 속성 제거
const { password: pwd, age, ...basicInfo } = user;
console.log(basicInfo);
// { name: 'Bob', email: 'bob@email.com' }
```

### 함수에서 객체 반환
```javascript
const updateUserProfile = (currentUser, updates) => {
    return {
        ...currentUser,
        ...updates,
        lastUpdated: new Date()
    };
};

const user = { name: 'Charlie', email: 'charlie@email.com' };
const updatedUser = updateUserProfile(user, { name: 'Charles', age: 25 });

console.log(updatedUser);
// { name: 'Charles', email: 'charlie@email.com', age: 25, lastUpdated: Date }
```

---

## 7. 주의사항과 한계점

### 1. 얕은 복사 문제
```javascript
const original = {
    user: { name: 'John' },
    hobbies: ['reading', 'coding']
};

const copied = { ...original };
copied.user.name = 'Jane';           // 원본도 변경됨!
copied.hobbies.push('swimming');      // 원본도 변경됨!

console.log(original.user.name);      // 'Jane'
console.log(original.hobbies);        // ['reading', 'coding', 'swimming']
```

### 2. 깊은 복사가 필요한 경우
```javascript
// 올바른 중첩 객체 업데이트
const updateNestedObject = (original, newUserName) => {
    return {
        ...original,
        user: {
            ...original.user,
            name: newUserName
        },
        hobbies: [...original.hobbies] // 배열도 스프레드로 복사
    };
};
```

### 3. 성능 고려사항
```javascript
// 큰 객체의 경우 성능 영향
const largeObject = { /* 수백 개의 속성 */ };

// 매번 전체 복사는 비효율적
const inefficient = { ...largeObject, oneProp: 'new value' };

// 필요한 경우만 복사하는 것이 좋음
const efficient = largeObject.oneProp === 'new value' 
    ? largeObject 
    : { ...largeObject, oneProp: 'new value' };
```

---

## 8. 실무 활용 팁

### 1. 기본값 설정 패턴
```javascript
const createConfig = (userConfig = {}) => {
    const defaultConfig = {
        theme: 'light',
        language: 'ko',
        showSidebar: true,
        autoSave: false
    };
    
    return {
        ...defaultConfig,
        ...userConfig  // 사용자 설정이 기본값을 덮어씀
    };
};
```

### 2. API 응답 변환
```javascript
const transformApiResponse = (apiData) => {
    return {
        ...apiData,
        id: apiData.user_id,        // 필드명 변경
        fullName: `${apiData.first_name} ${apiData.last_name}`,
        isActive: apiData.status === 'active',
        createdAt: new Date(apiData.created_at)
    };
};
```

### 3. React Hook Form과의 조합
```javascript
const [formData, setFormData] = useState({
    name: '',
    email: '',
    preferences: {
        newsletter: false,
        notifications: true
    }
});

const updateField = (field, value) => {
    setFormData(prev => ({
        ...prev,
        [field]: value
    }));
};

const updatePreference = (prefKey, value) => {
    setFormData(prev => ({
        ...prev,
        preferences: {
            ...prev.preferences,
            [prefKey]: value
        }
    }));
};
```

**핵심 기억사항:**
- 스프레드 문법은 **얕은 복사**만 수행
- **순서가 중요** - 나중에 오는 속성이 앞의 것을 덮어씀
- **불변성 유지**에 매우 유용 (특히 React에서)
- **중첩 객체는 별도 처리** 필요